{"ast":null,"code":"'use strict';\n/*\n4.1 authentication: (http://bazaar.launchpad.net/~mysql/mysql-server/5.5/view/head:/sql/password.c)\n\n  SERVER:  public_seed=create_random_string()\n           send(public_seed)\n\n  CLIENT:  recv(public_seed)\n           hash_stage1=sha1(\"password\")\n           hash_stage2=sha1(hash_stage1)\n           reply=xor(hash_stage1, sha1(public_seed,hash_stage2)\n\n           // this three steps are done in scramble()\n\n           send(reply)\n\n\n  SERVER:  recv(reply)\n           hash_stage1=xor(reply, sha1(public_seed,hash_stage2))\n           candidate_hash2=sha1(hash_stage1)\n           check(candidate_hash2==hash_stage2)\n\nserver stores sha1(sha1(password)) ( hash_stag2)\n*/\n\nconst crypto = require('crypto');\n\nfunction sha1(msg, msg1, msg2) {\n  const hash = crypto.createHash('sha1');\n  hash.update(msg);\n\n  if (msg1) {\n    hash.update(msg1);\n  }\n\n  if (msg2) {\n    hash.update(msg2);\n  }\n\n  return hash.digest();\n}\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a, 'binary');\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b, 'binary');\n  }\n\n  const result = Buffer.allocUnsafe(a.length);\n\n  for (let i = 0; i < a.length; i++) {\n    result[i] = a[i] ^ b[i];\n  }\n\n  return result;\n}\n\nexports.xor = xor;\n\nfunction token(password, scramble1, scramble2) {\n  // TODO: use buffers (not sure why strings here)\n  if (!password) {\n    return Buffer.alloc(0);\n  }\n\n  const stage1 = sha1(password);\n  return exports.calculateTokenFromPasswordSha(stage1, scramble1, scramble2);\n}\n\nexports.calculateTokenFromPasswordSha = function (passwordSha, scramble1, scramble2) {\n  // we use AUTH 41 here, and we need only the bytes we just need.\n  const authPluginData1 = scramble1.slice(0, 8);\n  const authPluginData2 = scramble2.slice(0, 12);\n  const stage2 = sha1(passwordSha);\n  const stage3 = sha1(authPluginData1, authPluginData2, stage2);\n  return xor(stage3, passwordSha);\n};\n\nexports.calculateToken = token;\n\nexports.verifyToken = function (publicSeed1, publicSeed2, token, doubleSha) {\n  const hashStage1 = xor(token, sha1(publicSeed1, publicSeed2, doubleSha));\n  const candidateHash2 = sha1(hashStage1);\n  return candidateHash2.compare(doubleSha) === 0;\n};\n\nexports.doubleSha1 = function (password) {\n  return sha1(sha1(password));\n};\n\nfunction xorRotating(a, seed) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a, 'binary');\n  }\n\n  if (!Buffer.isBuffer(seed)) {\n    seed = Buffer.from(seed, 'binary');\n  }\n\n  const result = Buffer.allocUnsafe(a.length);\n  const seedLen = seed.length;\n\n  for (let i = 0; i < a.length; i++) {\n    result[i] = a[i] ^ seed[i % seedLen];\n  }\n\n  return result;\n}\n\nexports.xorRotating = xorRotating;","map":{"version":3,"names":["crypto","require","sha1","msg","msg1","msg2","hash","createHash","update","digest","xor","a","b","Buffer","isBuffer","from","result","allocUnsafe","length","i","exports","token","password","scramble1","scramble2","alloc","stage1","calculateTokenFromPasswordSha","passwordSha","authPluginData1","slice","authPluginData2","stage2","stage3","calculateToken","verifyToken","publicSeed1","publicSeed2","doubleSha","hashStage1","candidateHash2","compare","doubleSha1","xorRotating","seed","seedLen"],"sources":["/home/emilio/Ãrea de Trabalho/OneBitCode-aulas/REACT/site-react-login-live/react-controlledForms/node_modules/mysql2/lib/auth_41.js"],"sourcesContent":["'use strict';\n\n/*\n4.1 authentication: (http://bazaar.launchpad.net/~mysql/mysql-server/5.5/view/head:/sql/password.c)\n\n  SERVER:  public_seed=create_random_string()\n           send(public_seed)\n\n  CLIENT:  recv(public_seed)\n           hash_stage1=sha1(\"password\")\n           hash_stage2=sha1(hash_stage1)\n           reply=xor(hash_stage1, sha1(public_seed,hash_stage2)\n\n           // this three steps are done in scramble()\n\n           send(reply)\n\n\n  SERVER:  recv(reply)\n           hash_stage1=xor(reply, sha1(public_seed,hash_stage2))\n           candidate_hash2=sha1(hash_stage1)\n           check(candidate_hash2==hash_stage2)\n\nserver stores sha1(sha1(password)) ( hash_stag2)\n*/\n\nconst crypto = require('crypto');\n\nfunction sha1(msg, msg1, msg2) {\n  const hash = crypto.createHash('sha1');\n  hash.update(msg);\n  if (msg1) {\n    hash.update(msg1);\n  }\n\n  if (msg2) {\n    hash.update(msg2);\n  }\n\n  return hash.digest();\n}\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a, 'binary');\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b, 'binary');\n  }\n\n  const result = Buffer.allocUnsafe(a.length);\n\n  for (let i = 0; i < a.length; i++) {\n    result[i] = a[i] ^ b[i];\n  }\n  return result;\n}\n\nexports.xor = xor;\n\nfunction token(password, scramble1, scramble2) {\n  // TODO: use buffers (not sure why strings here)\n  if (!password) {\n    return Buffer.alloc(0);\n  }\n  const stage1 = sha1(password);\n  return exports.calculateTokenFromPasswordSha(stage1, scramble1, scramble2);\n}\n\nexports.calculateTokenFromPasswordSha = function(\n  passwordSha,\n  scramble1,\n  scramble2\n) {\n  // we use AUTH 41 here, and we need only the bytes we just need.\n  const authPluginData1 = scramble1.slice(0, 8);\n  const authPluginData2 = scramble2.slice(0, 12);\n  const stage2 = sha1(passwordSha);\n  const stage3 = sha1(authPluginData1, authPluginData2, stage2);\n  return xor(stage3, passwordSha);\n};\n\nexports.calculateToken = token;\n\nexports.verifyToken = function(publicSeed1, publicSeed2, token, doubleSha) {\n  const hashStage1 = xor(token, sha1(publicSeed1, publicSeed2, doubleSha));\n  const candidateHash2 = sha1(hashStage1);\n  return candidateHash2.compare(doubleSha) === 0;\n};\n\nexports.doubleSha1 = function(password) {\n  return sha1(sha1(password));\n};\n\nfunction xorRotating(a, seed) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a, 'binary');\n  }\n\n  if (!Buffer.isBuffer(seed)) {\n    seed = Buffer.from(seed, 'binary');\n  }\n\n  const result = Buffer.allocUnsafe(a.length);\n  const seedLen = seed.length;\n\n  for (let i = 0; i < a.length; i++) {\n    result[i] = a[i] ^ seed[i % seedLen];\n  }\n  return result;\n}\nexports.xorRotating = xorRotating;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}