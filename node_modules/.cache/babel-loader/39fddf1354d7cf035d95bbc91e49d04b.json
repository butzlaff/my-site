{"ast":null,"code":";\n\n(function () {\n  'use strict';\n  /*jshint laxbreak: true,  browser:true */\n\n  /*global define*/\n\n  var esprima,\n      exportFn,\n      toString = Object.prototype.toString;\n\n  if (typeof module === 'object' && typeof module.exports === 'object' && typeof require === 'function') {\n    // server side\n    esprima = require('esprima');\n\n    exportFn = function (redeyed) {\n      module.exports = redeyed;\n    };\n\n    bootstrap(esprima, exportFn);\n  } else if (typeof define === 'function' && define.amd) {\n    // client side\n    // amd\n    define(['esprima'], function (esprima) {\n      return bootstrap(esprima);\n    });\n  } else if (typeof window === 'object') {\n    // no amd -> attach to window if it exists\n    // Note that this requires 'esprima' to be defined on the window, so that script has to be loaded first\n    window.redeyed = bootstrap(window.esprima);\n  }\n\n  function bootstrap(esprima, exportFn) {\n    function isFunction(obj) {\n      return toString.call(obj) === '[object Function]';\n    }\n\n    function isString(obj) {\n      return toString.call(obj) === '[object String]';\n    }\n\n    function isNumber(obj) {\n      return toString.call(obj) === '[object Number]';\n    }\n\n    function isObject(obj) {\n      return toString.call(obj) === '[object Object]';\n    }\n\n    function surroundWith(before, after) {\n      return function (s) {\n        return before + s + after;\n      };\n    }\n\n    function isNonCircular(key) {\n      return key !== '_parent';\n    }\n\n    function objectizeString(value) {\n      var vals = value.split(':');\n      if (0 === vals.length || vals.length > 2) throw new Error('illegal string config: ' + value + '\\nShould be of format \"before:after\"');\n\n      if (vals.length === 1 || vals[1].length === 0) {\n        return vals.indexOf(':') < 0 ? {\n          _before: vals[0]\n        } : {\n          _after: vals[0]\n        };\n      } else {\n        return {\n          _before: vals[0],\n          _after: vals[1]\n        };\n      }\n    }\n\n    function objectize(node) {\n      // Converts 'bef:aft' to { _before: bef, _after: aft } \n      // and resolves undefined before/after from parent or root\n      function resolve(value, key) {\n        // resolve before/after from root or parent if it isn't present on the current node\n        if (!value._parent) return undefined; // Immediate parent\n\n        if (value._parent._default && value._parent._default[key]) return value._parent._default[key]; // Root\n\n        var root = value._parent._parent;\n        if (!root) return undefined;\n        return root._default ? root._default[key] : undefined;\n      }\n\n      function process(key) {\n        var value = node[key];\n        if (!value) return;\n        if (isFunction(value)) return; // normalize all strings to objects\n\n        if (isString(value)) {\n          node[key] = value = objectizeString(value);\n        }\n\n        value._parent = node;\n\n        if (isObject(value)) {\n          if (!value._before && !value._after) return objectize(value); // resolve missing _before or _after from parent(s) \n          // in case we only have either one on this node\n\n          value._before = value._before || resolve(value, '_before');\n          value._after = value._after || resolve(value, '_after');\n          return;\n        }\n\n        throw new Error('nodes need to be either {String}, {Object} or {Function}.' + value + ' is neither.');\n      } // Process _default ones first so children can resolve missing before/after from them\n\n\n      if (node._default) process('_default');\n      Object.keys(node).filter(function (key) {\n        return isNonCircular(key) && node.hasOwnProperty(key) && key !== '_before' && key !== '_after' && key !== '_default';\n      }).forEach(process);\n    }\n\n    function functionize(node) {\n      Object.keys(node).filter(function (key) {\n        return isNonCircular(key) && node.hasOwnProperty(key);\n      }).forEach(function (key) {\n        var value = node[key];\n        if (isFunction(value)) return;\n\n        if (isObject(value)) {\n          if (!value._before && !value._after) return functionize(value); // at this point before/after were \"inherited\" from the parent or root\n          // (see objectize)\n\n          var before = value._before || '';\n          var after = value._after || '';\n          node[key] = surroundWith(before, after);\n          return node[key];\n        }\n      });\n    }\n\n    function normalize(root) {\n      objectize(root);\n      functionize(root);\n    }\n\n    function mergeTokensAndComments(tokens, comments) {\n      var all = {};\n\n      function addToAllByRangeStart(t) {\n        all[t.range[0]] = t;\n      }\n\n      tokens.forEach(addToAllByRangeStart);\n      comments.forEach(addToAllByRangeStart); // keys are sorted automatically\n\n      return Object.keys(all).map(function (k) {\n        return all[k];\n      });\n    }\n\n    function redeyed(code, config, opts) {\n      opts = opts || {}; // remove shebang\n\n      code = code.replace(/^\\#\\!.*/, '');\n      var ast = esprima.parse(code, {\n        tokens: true,\n        comment: true,\n        range: true,\n        tolerant: true\n      }),\n          tokens = ast.tokens,\n          comments = ast.comments,\n          lastSplitEnd = 0,\n          splits = [],\n          transformedCode,\n          all,\n          info;\n      normalize(config);\n\n      function tokenIndex(tokens, tkn, start) {\n        var current,\n            rangeStart = tkn.range[0];\n\n        for (current = start; current < tokens.length; current++) {\n          if (tokens[current].range[0] === rangeStart) return current;\n        }\n\n        throw new Error('Token %s not found at or after index: %d', tkn, start);\n      }\n\n      function process(surround) {\n        var result,\n            currentIndex,\n            nextIndex,\n            skip = 0,\n            splitEnd;\n        result = surround(code.slice(start, end), info);\n\n        if (isObject(result)) {\n          splits.push(result.replacement);\n          currentIndex = info.tokenIndex;\n          nextIndex = tokenIndex(info.tokens, result.skipPastToken, currentIndex);\n          skip = nextIndex - currentIndex;\n          splitEnd = skip > 0 ? tokens[nextIndex - 1].range[1] : end;\n        } else {\n          splits.push(result);\n          splitEnd = end;\n        }\n\n        return {\n          skip: skip,\n          splitEnd: splitEnd\n        };\n      }\n\n      function addSplit(start, end, surround, info) {\n        var result,\n            nextIndex,\n            skip = 0;\n        if (start >= end) return;\n\n        if (surround) {\n          result = process(surround);\n          skip = result.skip;\n          lastSplitEnd = result.splitEnd;\n        } else {\n          splits.push(code.slice(start, end));\n          lastSplitEnd = end;\n        }\n\n        return skip;\n      }\n\n      all = mergeTokensAndComments(tokens, comments);\n\n      for (var tokenIdx = 0; tokenIdx < all.length; tokenIdx++) {\n        var token = all[tokenIdx],\n            surroundForType = config[token.type],\n            surround,\n            start,\n            end; // At least the type (e.g., 'Keyword') needs to be specified for the token to be surrounded\n\n        if (surroundForType) {\n          // root defaults are only taken into account while resolving before/after otherwise\n          // a root default would apply to everything, even if no type default was specified\n          surround = surroundForType && surroundForType.hasOwnProperty(token.value) && surroundForType[token.value] && isFunction(surroundForType[token.value]) ? surroundForType[token.value] : surroundForType._default;\n          start = token.range[0];\n          end = token.range[1];\n          addSplit(lastSplitEnd, start);\n          info = {\n            tokenIndex: tokenIdx,\n            tokens: all,\n            ast: ast,\n            code: code\n          };\n          tokenIdx += addSplit(start, end, surround, info);\n        }\n      }\n\n      if (lastSplitEnd < code.length) {\n        addSplit(lastSplitEnd, code.length);\n      }\n\n      transformedCode = opts.nojoin ? undefined : splits.join('');\n      return {\n        ast: ast,\n        tokens: tokens,\n        comments: comments,\n        splits: splits,\n        code: transformedCode\n      };\n    }\n\n    return exportFn ? exportFn(redeyed) : redeyed;\n  }\n})();","map":{"version":3,"names":["esprima","exportFn","toString","Object","prototype","module","exports","require","redeyed","bootstrap","define","amd","window","isFunction","obj","call","isString","isNumber","isObject","surroundWith","before","after","s","isNonCircular","key","objectizeString","value","vals","split","length","Error","indexOf","_before","_after","objectize","node","resolve","_parent","undefined","_default","root","process","keys","filter","hasOwnProperty","forEach","functionize","normalize","mergeTokensAndComments","tokens","comments","all","addToAllByRangeStart","t","range","map","k","code","config","opts","replace","ast","parse","comment","tolerant","lastSplitEnd","splits","transformedCode","info","tokenIndex","tkn","start","current","rangeStart","surround","result","currentIndex","nextIndex","skip","splitEnd","slice","end","push","replacement","skipPastToken","addSplit","tokenIdx","token","surroundForType","type","nojoin","join"],"sources":["/home/emilio/Ãrea de Trabalho/OneBitCode-aulas/REACT/site-react-login-live/react-controlledForms/node_modules/redeyed/redeyed.js"],"sourcesContent":[";(function () {\n\n'use strict';\n/*jshint laxbreak: true,  browser:true */\n/*global define*/\n\nvar esprima\n  , exportFn\n  , toString = Object.prototype.toString\n  ;\n\nif (typeof module === 'object' && typeof module.exports === 'object' && typeof require === 'function') {\n  // server side\n  esprima = require('esprima');\n  exportFn = function (redeyed) { module.exports = redeyed; };\n  bootstrap(esprima, exportFn);\n} else if (typeof define === 'function' && define.amd) {\n  // client side\n  // amd\n  define(['esprima'], function (esprima) {\n      return bootstrap(esprima);\n  });\n} else if (typeof window === 'object') {\n  // no amd -> attach to window if it exists\n  // Note that this requires 'esprima' to be defined on the window, so that script has to be loaded first\n  window.redeyed = bootstrap(window.esprima);\n}\n\nfunction bootstrap(esprima, exportFn) {\n\n  function isFunction (obj) {\n    return toString.call(obj) === '[object Function]';\n  }\n\n  function isString (obj) {\n    return toString.call(obj) === '[object String]';\n  }\n\n  function isNumber (obj) {\n    return toString.call(obj) === '[object Number]';\n  }\n\n  function isObject (obj) {\n    return toString.call(obj) === '[object Object]';\n  }\n\n  function surroundWith (before, after) {\n    return function (s) { return before + s + after; };\n  }\n\n  function isNonCircular(key) { \n    return key !== '_parent'; \n  }\n\n  function objectizeString (value) {\n    var vals = value.split(':');\n\n    if (0 === vals.length || vals.length > 2) \n      throw new Error(\n        'illegal string config: ' + value +\n        '\\nShould be of format \"before:after\"'\n      );\n\n    if (vals.length === 1 || vals[1].length === 0) {\n      return vals.indexOf(':') < 0 ? { _before: vals[0] } : { _after: vals[0] };\n    } else {\n      return { _before: vals[0], _after: vals[1] };\n    }\n  }\n\n  function objectize (node) {\n\n    // Converts 'bef:aft' to { _before: bef, _after: aft } \n    // and resolves undefined before/after from parent or root\n\n    function resolve (value, key) {\n      // resolve before/after from root or parent if it isn't present on the current node\n      if (!value._parent) return undefined;\n      \n      // Immediate parent\n      if (value._parent._default && value._parent._default[key]) return value._parent._default[key];\n\n      // Root\n      var root = value._parent._parent;\n      if (!root) return undefined;\n\n      return root._default ? root._default[key] : undefined;\n    }\n\n    function process (key) {\n      var value = node[key];\n\n      if (!value) return;\n      if (isFunction(value)) return;\n\n      // normalize all strings to objects\n      if (isString(value)) {\n        node[key] = value = objectizeString(value);\n      }\n      \n      value._parent = node;\n      if (isObject(value)) {\n        if (!value._before && !value._after) return objectize (value);\n\n        // resolve missing _before or _after from parent(s) \n        // in case we only have either one on this node\n        value._before =  value._before || resolve(value, '_before');\n        value._after  =  value._after  || resolve(value, '_after');\n        \n        return;\n      } \n\n      throw new Error('nodes need to be either {String}, {Object} or {Function}.' + value + ' is neither.');\n    }\n\n    // Process _default ones first so children can resolve missing before/after from them\n    if (node._default) process('_default');\n\n    Object.keys(node)\n      .filter(function (key) {\n        return isNonCircular(key) \n          && node.hasOwnProperty(key)\n          && key !== '_before' \n          && key !== '_after' \n          && key !== '_default';\n      })\n      .forEach(process);\n  }\n\n  function functionize (node) {\n    Object.keys(node)\n      .filter(function (key) { \n        return isNonCircular(key) && node.hasOwnProperty(key);\n      })\n      .forEach(function (key) {\n        var value = node[key];\n\n        if (isFunction(value)) return;\n\n        if (isObject(value)) {\n\n          if (!value._before && !value._after) return functionize(value);\n\n          // at this point before/after were \"inherited\" from the parent or root\n          // (see objectize)\n          var before = value._before || '';\n          var after = value._after || '';\n\n          node[key] = surroundWith (before, after);\n          return node[key];\n        }\n      });\n  }\n\n  function normalize (root) {\n    objectize(root);\n    functionize(root);\n  }\n\n  function mergeTokensAndComments(tokens, comments) {\n    var all = {};\n\n    function addToAllByRangeStart(t) { all[ t.range[0] ] = t; }\n\n    tokens.forEach(addToAllByRangeStart);\n    comments.forEach(addToAllByRangeStart);\n\n    // keys are sorted automatically\n    return Object.keys(all)\n      .map(function (k) { return all[k]; });\n  }\n\n  function redeyed (code, config, opts) {\n    opts = opts || {};\n\n    // remove shebang\n    code = code.replace(/^\\#\\!.*/, '');\n\n    var ast = esprima.parse(code, { tokens: true, comment: true, range: true, tolerant: true })\n      , tokens = ast.tokens\n      , comments = ast.comments\n      , lastSplitEnd = 0\n      , splits = []\n      , transformedCode\n      , all\n      , info\n      ;\n\n    normalize(config);\n\n    function tokenIndex(tokens, tkn, start) {\n      var current\n        , rangeStart = tkn.range[0];\n\n      for (current = start; current < tokens.length; current++) {\n        if (tokens[current].range[0] === rangeStart) return current;\n      }\n\n      throw new Error('Token %s not found at or after index: %d', tkn, start);\n    }\n\n    function process(surround) {\n      var result\n        , currentIndex\n        , nextIndex\n        , skip = 0\n        , splitEnd\n        ;\n\n      result = surround(code.slice(start, end), info);\n      if (isObject(result)) {\n        splits.push(result.replacement);\n\n        currentIndex =  info.tokenIndex;\n        nextIndex    =  tokenIndex(info.tokens, result.skipPastToken, currentIndex);\n        skip         =  nextIndex - currentIndex;\n        splitEnd     =  skip > 0 ? tokens[nextIndex - 1].range[1] : end;\n      } else {\n        splits.push(result);\n        splitEnd = end;\n      }\n\n      return { skip: skip, splitEnd: splitEnd  };\n    }\n\n    function addSplit (start, end, surround, info) {\n      var result\n        , nextIndex\n        , skip = 0\n        ;\n\n      if (start >= end) return;\n      if (surround) {\n        result       =  process(surround);\n        skip         =  result.skip;\n        lastSplitEnd =  result.splitEnd;\n      } else {\n        splits.push(code.slice(start, end));\n        lastSplitEnd = end;\n      }\n\n      return skip;\n    }\n\n    all = mergeTokensAndComments(tokens, comments);\n    for (var tokenIdx = 0; tokenIdx < all.length; tokenIdx++) {\n      var token = all[tokenIdx]\n        , surroundForType = config[token.type]\n        , surround\n        , start\n        , end;\n      \n      // At least the type (e.g., 'Keyword') needs to be specified for the token to be surrounded\n      if (surroundForType) {\n\n        // root defaults are only taken into account while resolving before/after otherwise\n        // a root default would apply to everything, even if no type default was specified\n        surround = surroundForType \n          && surroundForType.hasOwnProperty(token.value) \n          && surroundForType[token.value]\n          && isFunction(surroundForType[token.value])\n            ? surroundForType[token.value] \n            : surroundForType._default;\n\n        start = token.range[0];\n        end = token.range[1];\n\n        addSplit(lastSplitEnd, start);\n        info = { tokenIndex: tokenIdx, tokens: all, ast: ast, code: code };\n        tokenIdx += addSplit(start, end, surround, info);\n      }\n    }\n\n    if (lastSplitEnd < code.length) {\n      addSplit(lastSplitEnd, code.length);\n    }\n\n  transformedCode = opts.nojoin ? undefined : splits.join('');\n\n    return { \n        ast      :  ast\n      , tokens   :  tokens\n      , comments :  comments\n      , splits   :  splits\n      , code     :  transformedCode\n    };\n  }\n\n  return exportFn ? exportFn(redeyed) : redeyed;\n}\n})();\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}