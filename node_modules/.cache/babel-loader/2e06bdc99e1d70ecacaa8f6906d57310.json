{"ast":null,"code":"'use strict';\n\nconst process = require('process');\n\nconst Pool = require('./pool.js');\n\nconst PoolConfig = require('./pool_config.js');\n\nconst Connection = require('./connection.js');\n\nconst EventEmitter = require('events').EventEmitter;\n/**\n * Selector\n */\n\n\nconst makeSelector = {\n  RR() {\n    let index = 0;\n    return clusterIds => clusterIds[index++ % clusterIds.length];\n  },\n\n  RANDOM() {\n    return clusterIds => clusterIds[Math.floor(Math.random() * clusterIds.length)];\n  },\n\n  ORDER() {\n    return clusterIds => clusterIds[0];\n  }\n\n};\n\nclass PoolNamespace {\n  constructor(cluster, pattern, selector) {\n    this._cluster = cluster;\n    this._pattern = pattern;\n    this._selector = makeSelector[selector]();\n  }\n\n  getConnection(cb) {\n    const clusterNode = this._getClusterNode();\n\n    if (clusterNode === null) {\n      return cb(new Error('Pool does Not exists.'));\n    }\n\n    return this._cluster._getConnection(clusterNode, (err, connection) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (connection === 'retry') {\n        return this.getConnection(cb);\n      }\n\n      return cb(null, connection);\n    });\n  }\n  /**\n   * pool cluster query\n   * @param {*} sql\n   * @param {*} values\n   * @param {*} cb\n   * @returns query\n   */\n\n\n  query(sql, values, cb) {\n    const query = Connection.createQuery(sql, values, cb, {});\n    this.getConnection((err, conn) => {\n      if (err) {\n        if (typeof query.onResult === 'function') {\n          query.onResult(err);\n        } else {\n          query.emit('error', err);\n        }\n\n        return;\n      }\n\n      try {\n        conn.query(query).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n    return query;\n  }\n  /**\n   * pool cluster execute\n   * @param {*} sql \n   * @param {*} values \n   * @param {*} cb \n   */\n\n\n  execute(sql, values, cb) {\n    if (typeof values === 'function') {\n      cb = values;\n      values = [];\n    }\n\n    this.getConnection((err, conn) => {\n      if (err) {\n        return cb(err);\n      }\n\n      try {\n        conn.execute(sql, values, cb).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n  }\n\n  _getClusterNode() {\n    const foundNodeIds = this._cluster._findNodeIds(this._pattern);\n\n    if (foundNodeIds.length === 0) {\n      return null;\n    }\n\n    const nodeId = foundNodeIds.length === 1 ? foundNodeIds[0] : this._selector(foundNodeIds);\n    return this._cluster._getNode(nodeId);\n  }\n\n}\n\nclass PoolCluster extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this._canRetry = typeof config.canRetry === 'undefined' ? true : config.canRetry;\n    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;\n    this._defaultSelector = config.defaultSelector || 'RR';\n    this._closed = false;\n    this._lastId = 0;\n    this._nodes = {};\n    this._serviceableNodeIds = [];\n    this._namespaces = {};\n    this._findCaches = {};\n  }\n\n  of(pattern, selector) {\n    pattern = pattern || '*';\n    selector = selector || this._defaultSelector;\n    selector = selector.toUpperCase();\n\n    if (!makeSelector[selector] === 'undefined') {\n      selector = this._defaultSelector;\n    }\n\n    const key = pattern + selector;\n\n    if (typeof this._namespaces[key] === 'undefined') {\n      this._namespaces[key] = new PoolNamespace(this, pattern, selector);\n    }\n\n    return this._namespaces[key];\n  }\n\n  add(id, config) {\n    if (typeof id === 'object') {\n      config = id;\n      id = `CLUSTER::${++this._lastId}`;\n    }\n\n    if (typeof this._nodes[id] === 'undefined') {\n      this._nodes[id] = {\n        id: id,\n        errorCount: 0,\n        pool: new Pool({\n          config: new PoolConfig(config)\n        })\n      };\n\n      this._serviceableNodeIds.push(id);\n\n      this._clearFindCaches();\n    }\n  }\n\n  getConnection(pattern, selector, cb) {\n    let namespace;\n\n    if (typeof pattern === 'function') {\n      cb = pattern;\n      namespace = this.of();\n    } else {\n      if (typeof selector === 'function') {\n        cb = selector;\n        selector = this._defaultSelector;\n      }\n\n      namespace = this.of(pattern, selector);\n    }\n\n    namespace.getConnection(cb);\n  }\n\n  end(callback) {\n    const cb = callback !== undefined ? callback : err => {\n      if (err) {\n        throw err;\n      }\n    };\n\n    if (this._closed) {\n      process.nextTick(cb);\n      return;\n    }\n\n    this._closed = true;\n    let calledBack = false;\n    let waitingClose = 0;\n\n    const onEnd = err => {\n      if (!calledBack && (err || --waitingClose <= 0)) {\n        calledBack = true;\n        return cb(err);\n      }\n    };\n\n    for (const id in this._nodes) {\n      waitingClose++;\n\n      this._nodes[id].pool.end(onEnd);\n    }\n\n    if (waitingClose === 0) {\n      process.nextTick(onEnd);\n    }\n  }\n\n  _findNodeIds(pattern) {\n    if (typeof this._findCaches[pattern] !== 'undefined') {\n      return this._findCaches[pattern];\n    }\n\n    let foundNodeIds;\n\n    if (pattern === '*') {\n      // all\n      foundNodeIds = this._serviceableNodeIds;\n    } else if (this._serviceableNodeIds.indexOf(pattern) !== -1) {\n      // one\n      foundNodeIds = [pattern];\n    } else {\n      // wild matching\n      const keyword = pattern.substring(pattern.length - 1, 0);\n      foundNodeIds = this._serviceableNodeIds.filter(id => id.startsWith(keyword));\n    }\n\n    this._findCaches[pattern] = foundNodeIds;\n    return foundNodeIds;\n  }\n\n  _getNode(id) {\n    return this._nodes[id] || null;\n  }\n\n  _increaseErrorCount(node) {\n    if (++node.errorCount >= this._removeNodeErrorCount) {\n      const index = this._serviceableNodeIds.indexOf(node.id);\n\n      if (index !== -1) {\n        this._serviceableNodeIds.splice(index, 1);\n\n        delete this._nodes[node.id];\n\n        this._clearFindCaches();\n\n        node.pool.end();\n        this.emit('remove', node.id);\n      }\n    }\n  }\n\n  _decreaseErrorCount(node) {\n    if (node.errorCount > 0) {\n      --node.errorCount;\n    }\n  }\n\n  _getConnection(node, cb) {\n    node.pool.getConnection((err, connection) => {\n      if (err) {\n        this._increaseErrorCount(node);\n\n        if (this._canRetry) {\n          // REVIEW: this seems wrong?\n          this.emit('warn', err); // eslint-disable-next-line no-console\n\n          console.warn(`[Error] PoolCluster : ${err}`);\n          return cb(null, 'retry');\n        }\n\n        return cb(err);\n      }\n\n      this._decreaseErrorCount(node);\n\n      connection._clusterId = node.id;\n      return cb(null, connection);\n    });\n  }\n\n  _clearFindCaches() {\n    this._findCaches = {};\n  }\n\n}\n\nmodule.exports = PoolCluster;","map":{"version":3,"names":["process","require","Pool","PoolConfig","Connection","EventEmitter","makeSelector","RR","index","clusterIds","length","RANDOM","Math","floor","random","ORDER","PoolNamespace","constructor","cluster","pattern","selector","_cluster","_pattern","_selector","getConnection","cb","clusterNode","_getClusterNode","Error","_getConnection","err","connection","query","sql","values","createQuery","conn","onResult","emit","once","release","e","execute","foundNodeIds","_findNodeIds","nodeId","_getNode","PoolCluster","config","_canRetry","canRetry","_removeNodeErrorCount","removeNodeErrorCount","_defaultSelector","defaultSelector","_closed","_lastId","_nodes","_serviceableNodeIds","_namespaces","_findCaches","of","toUpperCase","key","add","id","errorCount","pool","push","_clearFindCaches","namespace","end","callback","undefined","nextTick","calledBack","waitingClose","onEnd","indexOf","keyword","substring","filter","startsWith","_increaseErrorCount","node","splice","_decreaseErrorCount","console","warn","_clusterId","module","exports"],"sources":["/home/emilio/Ãrea de Trabalho/OneBitCode-aulas/REACT/site-react-login-live/react-controlledForms/node_modules/mysql2/lib/pool_cluster.js"],"sourcesContent":["'use strict';\n\nconst process = require('process');\n\nconst Pool = require('./pool.js');\nconst PoolConfig = require('./pool_config.js');\nconst Connection = require('./connection.js');\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Selector\n */\nconst makeSelector = {\n  RR() {\n    let index = 0;\n    return clusterIds => clusterIds[index++ % clusterIds.length];\n  },\n  RANDOM() {\n    return clusterIds =>\n      clusterIds[Math.floor(Math.random() * clusterIds.length)];\n  },\n  ORDER() {\n    return clusterIds => clusterIds[0];\n  }\n};\n\nclass PoolNamespace {\n  constructor(cluster, pattern, selector) {\n    this._cluster = cluster;\n    this._pattern = pattern;\n    this._selector = makeSelector[selector]();\n  }\n\n  getConnection(cb) {\n    const clusterNode = this._getClusterNode();\n    if (clusterNode === null) {\n      return cb(new Error('Pool does Not exists.'));\n    }\n    return this._cluster._getConnection(clusterNode, (err, connection) => {\n      if (err) {\n        return cb(err);\n      }\n      if (connection === 'retry') {\n        return this.getConnection(cb);\n      }\n      return cb(null, connection);\n    });\n  }\n\n  /**\n   * pool cluster query\n   * @param {*} sql\n   * @param {*} values\n   * @param {*} cb\n   * @returns query\n   */\n  query(sql, values, cb) {\n    const query = Connection.createQuery(sql, values, cb, {});\n    this.getConnection((err, conn) => {\n      if (err) {\n        if (typeof query.onResult === 'function') {\n          query.onResult(err);\n        } else {\n          query.emit('error', err);\n        }\n        return;\n      }\n      try {\n        conn.query(query).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n    return query;\n  }\n\n  /**\n   * pool cluster execute\n   * @param {*} sql \n   * @param {*} values \n   * @param {*} cb \n   */\n  execute(sql, values, cb) {\n    if (typeof values === 'function') {\n      cb = values;\n      values = [];\n    }\n    this.getConnection((err, conn) => {\n      if (err) {\n        return cb(err);\n      }\n      try {\n        conn.execute(sql, values, cb).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n  }\n\n  _getClusterNode() {\n    const foundNodeIds = this._cluster._findNodeIds(this._pattern);\n    if (foundNodeIds.length === 0) {\n      return null;\n    }\n    const nodeId =\n      foundNodeIds.length === 1\n        ? foundNodeIds[0]\n        : this._selector(foundNodeIds);\n    return this._cluster._getNode(nodeId);\n  }\n}\n\nclass PoolCluster extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this._canRetry =\n      typeof config.canRetry === 'undefined' ? true : config.canRetry;\n    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;\n    this._defaultSelector = config.defaultSelector || 'RR';\n    this._closed = false;\n    this._lastId = 0;\n    this._nodes = {};\n    this._serviceableNodeIds = [];\n    this._namespaces = {};\n    this._findCaches = {};\n  }\n\n  of(pattern, selector) {\n    pattern = pattern || '*';\n    selector = selector || this._defaultSelector;\n    selector = selector.toUpperCase();\n    if (!makeSelector[selector] === 'undefined') {\n      selector = this._defaultSelector;\n    }\n    const key = pattern + selector;\n    if (typeof this._namespaces[key] === 'undefined') {\n      this._namespaces[key] = new PoolNamespace(this, pattern, selector);\n    }\n    return this._namespaces[key];\n  }\n\n  add(id, config) {\n    if (typeof id === 'object') {\n      config = id;\n      id = `CLUSTER::${++this._lastId}`;\n    }\n    if (typeof this._nodes[id] === 'undefined') {\n      this._nodes[id] = {\n        id: id,\n        errorCount: 0,\n        pool: new Pool({ config: new PoolConfig(config) })\n      };\n      this._serviceableNodeIds.push(id);\n      this._clearFindCaches();\n    }\n  }\n\n  getConnection(pattern, selector, cb) {\n    let namespace;\n    if (typeof pattern === 'function') {\n      cb = pattern;\n      namespace = this.of();\n    } else {\n      if (typeof selector === 'function') {\n        cb = selector;\n        selector = this._defaultSelector;\n      }\n      namespace = this.of(pattern, selector);\n    }\n    namespace.getConnection(cb);\n  }\n\n  end(callback) {\n    const cb =\n      callback !== undefined\n        ? callback\n        : err => {\n          if (err) {\n            throw err;\n          }\n        };\n    if (this._closed) {\n      process.nextTick(cb);\n      return;\n    }\n    this._closed = true;\n\n    let calledBack = false;\n    let waitingClose = 0;\n    const onEnd = err => {\n      if (!calledBack && (err || --waitingClose <= 0)) {\n        calledBack = true;\n        return cb(err);\n      }\n    };\n\n    for (const id in this._nodes) {\n      waitingClose++;\n      this._nodes[id].pool.end(onEnd);\n    }\n    if (waitingClose === 0) {\n      process.nextTick(onEnd);\n    }\n  }\n\n  _findNodeIds(pattern) {\n    if (typeof this._findCaches[pattern] !== 'undefined') {\n      return this._findCaches[pattern];\n    }\n    let foundNodeIds;\n    if (pattern === '*') {\n      // all\n      foundNodeIds = this._serviceableNodeIds;\n    } else if (this._serviceableNodeIds.indexOf(pattern) !== -1) {\n      // one\n      foundNodeIds = [pattern];\n    } else {\n      // wild matching\n      const keyword = pattern.substring(pattern.length - 1, 0);\n      foundNodeIds = this._serviceableNodeIds.filter(id =>\n        id.startsWith(keyword)\n      );\n    }\n    this._findCaches[pattern] = foundNodeIds;\n    return foundNodeIds;\n  }\n\n  _getNode(id) {\n    return this._nodes[id] || null;\n  }\n\n  _increaseErrorCount(node) {\n    if (++node.errorCount >= this._removeNodeErrorCount) {\n      const index = this._serviceableNodeIds.indexOf(node.id);\n      if (index !== -1) {\n        this._serviceableNodeIds.splice(index, 1);\n        delete this._nodes[node.id];\n        this._clearFindCaches();\n        node.pool.end();\n        this.emit('remove', node.id);\n      }\n    }\n  }\n\n  _decreaseErrorCount(node) {\n    if (node.errorCount > 0) {\n      --node.errorCount;\n    }\n  }\n\n  _getConnection(node, cb) {\n    node.pool.getConnection((err, connection) => {\n      if (err) {\n        this._increaseErrorCount(node);\n        if (this._canRetry) {\n          // REVIEW: this seems wrong?\n          this.emit('warn', err);\n          // eslint-disable-next-line no-console\n          console.warn(`[Error] PoolCluster : ${err}`);\n          return cb(null, 'retry');\n        }\n        return cb(err);\n      }\n      this._decreaseErrorCount(node);\n\n      connection._clusterId = node.id;\n      return cb(null, connection);\n    });\n  }\n\n  _clearFindCaches() {\n    this._findCaches = {};\n  }\n}\n\nmodule.exports = PoolCluster;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}