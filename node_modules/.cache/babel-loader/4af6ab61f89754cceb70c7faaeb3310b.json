{"ast":null,"code":"/*\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n\n/*global esprima:true, define:true, exports:true, window: true,\nthrowError: true, createLiteral: true, generateStatement: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseStatement: true, parseSourceElement: true */\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n  // Rhino, and plain browser loading.\n\n  if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    factory(root.esprima = {});\n  }\n})(this, function (exports) {\n  'use strict';\n\n  var Token, TokenName, Syntax, PropertyKind, Messages, Regex, source, strict, index, lineNumber, lineStart, length, buffer, state, extra;\n  Token = {\n    BooleanLiteral: 1,\n    EOF: 2,\n    Identifier: 3,\n    Keyword: 4,\n    NullLiteral: 5,\n    NumericLiteral: 6,\n    Punctuator: 7,\n    StringLiteral: 8\n  };\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  Syntax = {\n    AssignmentExpression: 'AssignmentExpression',\n    ArrayExpression: 'ArrayExpression',\n    BlockStatement: 'BlockStatement',\n    BinaryExpression: 'BinaryExpression',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DoWhileStatement: 'DoWhileStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExpressionStatement: 'ExpressionStatement',\n    ForStatement: 'ForStatement',\n    ForInStatement: 'ForInStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    Literal: 'Literal',\n    LabeledStatement: 'LabeledStatement',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    NewExpression: 'NewExpression',\n    ObjectExpression: 'ObjectExpression',\n    Program: 'Program',\n    Property: 'Property',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SwitchStatement: 'SwitchStatement',\n    SwitchCase: 'SwitchCase',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement'\n  };\n  PropertyKind = {\n    Data: 1,\n    Get: 2,\n    Set: 4\n  }; // Error messages should be identical to V8.\n\n  Messages = {\n    UnexpectedToken: 'Unexpected token %0',\n    UnexpectedNumber: 'Unexpected number',\n    UnexpectedString: 'Unexpected string',\n    UnexpectedIdentifier: 'Unexpected identifier',\n    UnexpectedReserved: 'Unexpected reserved word',\n    UnexpectedEOS: 'Unexpected end of input',\n    NewlineAfterThrow: 'Illegal newline after throw',\n    InvalidRegExp: 'Invalid regular expression',\n    UnterminatedRegExp: 'Invalid regular expression: missing /',\n    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n    InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n    NoCatchOrFinally: 'Missing catch or finally after try',\n    UnknownLabel: 'Undefined label \\'%0\\'',\n    Redeclaration: '%0 \\'%1\\' has already been declared',\n    IllegalContinue: 'Illegal continue statement',\n    IllegalBreak: 'Illegal break statement',\n    IllegalReturn: 'Illegal return statement',\n    StrictModeWith: 'Strict mode code may not include a with statement',\n    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n    StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n    StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n    StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',\n    AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',\n    AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',\n    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictReservedWord: 'Use of future reserved word in strict mode'\n  }; // See also tools/generate-unicode-regex.py.\n\n  Regex = {\n    NonAsciiIdentifierStart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n    NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n  }; // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n    if (!condition) {\n      throw new Error('ASSERT: ' + message);\n    }\n  }\n\n  function sliceSource(from, to) {\n    return source.slice(from, to);\n  }\n\n  if (typeof 'esprima'[0] === 'undefined') {\n    sliceSource = function sliceArraySource(from, to) {\n      return source.slice(from, to).join('');\n    };\n  }\n\n  function isDecimalDigit(ch) {\n    return '0123456789'.indexOf(ch) >= 0;\n  }\n\n  function isHexDigit(ch) {\n    return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n    return '01234567'.indexOf(ch) >= 0;\n  } // 7.2 White Space\n\n\n  function isWhiteSpace(ch) {\n    return ch === ' ' || ch === '\\u0009' || ch === '\\u000B' || ch === '\\u000C' || ch === '\\u00A0' || ch.charCodeAt(0) >= 0x1680 && '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(ch) >= 0;\n  } // 7.3 Line Terminators\n\n\n  function isLineTerminator(ch) {\n    return ch === '\\n' || ch === '\\r' || ch === '\\u2028' || ch === '\\u2029';\n  } // 7.6 Identifier Names and Identifiers\n\n\n  function isIdentifierStart(ch) {\n    return ch === '$' || ch === '_' || ch === '\\\\' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch.charCodeAt(0) >= 0x80 && Regex.NonAsciiIdentifierStart.test(ch);\n  }\n\n  function isIdentifierPart(ch) {\n    return ch === '$' || ch === '_' || ch === '\\\\' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch.charCodeAt(0) >= 0x80 && Regex.NonAsciiIdentifierPart.test(ch);\n  } // 7.6.1.2 Future Reserved Words\n\n\n  function isFutureReservedWord(id) {\n    switch (id) {\n      // Future reserved words.\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n        return true;\n    }\n\n    return false;\n  }\n\n  function isStrictModeReservedWord(id) {\n    switch (id) {\n      // Strict Mode reserved words.\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n        return true;\n    }\n\n    return false;\n  }\n\n  function isRestrictedWord(id) {\n    return id === 'eval' || id === 'arguments';\n  } // 7.6.1.1 Keywords\n\n\n  function isKeyword(id) {\n    var keyword = false;\n\n    switch (id.length) {\n      case 2:\n        keyword = id === 'if' || id === 'in' || id === 'do';\n        break;\n\n      case 3:\n        keyword = id === 'var' || id === 'for' || id === 'new' || id === 'try';\n        break;\n\n      case 4:\n        keyword = id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with';\n        break;\n\n      case 5:\n        keyword = id === 'while' || id === 'break' || id === 'catch' || id === 'throw';\n        break;\n\n      case 6:\n        keyword = id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch';\n        break;\n\n      case 7:\n        keyword = id === 'default' || id === 'finally';\n        break;\n\n      case 8:\n        keyword = id === 'function' || id === 'continue' || id === 'debugger';\n        break;\n\n      case 10:\n        keyword = id === 'instanceof';\n        break;\n    }\n\n    if (keyword) {\n      return true;\n    }\n\n    switch (id) {\n      // Future reserved words.\n      // 'const' is specialized as Keyword in V8.\n      case 'const':\n        return true;\n      // For compatiblity to SpiderMonkey and ES.next\n\n      case 'yield':\n      case 'let':\n        return true;\n    }\n\n    if (strict && isStrictModeReservedWord(id)) {\n      return true;\n    }\n\n    return isFutureReservedWord(id);\n  } // 7.4 Comments\n\n\n  function skipComment() {\n    var ch, blockComment, lineComment;\n    blockComment = false;\n    lineComment = false;\n\n    while (index < length) {\n      ch = source[index];\n\n      if (lineComment) {\n        ch = source[index++];\n\n        if (isLineTerminator(ch)) {\n          lineComment = false;\n\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n\n          ++lineNumber;\n          lineStart = index;\n        }\n      } else if (blockComment) {\n        if (isLineTerminator(ch)) {\n          if (ch === '\\r' && source[index + 1] === '\\n') {\n            ++index;\n          }\n\n          ++lineNumber;\n          ++index;\n          lineStart = index;\n\n          if (index >= length) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n        } else {\n          ch = source[index++];\n\n          if (index >= length) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n\n          if (ch === '*') {\n            ch = source[index];\n\n            if (ch === '/') {\n              ++index;\n              blockComment = false;\n            }\n          }\n        }\n      } else if (ch === '/') {\n        ch = source[index + 1];\n\n        if (ch === '/') {\n          index += 2;\n          lineComment = true;\n        } else if (ch === '*') {\n          index += 2;\n          blockComment = true;\n\n          if (index >= length) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n        } else {\n          break;\n        }\n      } else if (isWhiteSpace(ch)) {\n        ++index;\n      } else if (isLineTerminator(ch)) {\n        ++index;\n\n        if (ch === '\\r' && source[index] === '\\n') {\n          ++index;\n        }\n\n        ++lineNumber;\n        lineStart = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n  function scanHexEscape(prefix) {\n    var i,\n        len,\n        ch,\n        code = 0;\n    len = prefix === 'u' ? 4 : 2;\n\n    for (i = 0; i < len; ++i) {\n      if (index < length && isHexDigit(source[index])) {\n        ch = source[index++];\n        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      } else {\n        return '';\n      }\n    }\n\n    return String.fromCharCode(code);\n  }\n\n  function scanIdentifier() {\n    var ch, start, id, restore;\n    ch = source[index];\n\n    if (!isIdentifierStart(ch)) {\n      return;\n    }\n\n    start = index;\n\n    if (ch === '\\\\') {\n      ++index;\n\n      if (source[index] !== 'u') {\n        return;\n      }\n\n      ++index;\n      restore = index;\n      ch = scanHexEscape('u');\n\n      if (ch) {\n        if (ch === '\\\\' || !isIdentifierStart(ch)) {\n          return;\n        }\n\n        id = ch;\n      } else {\n        index = restore;\n        id = 'u';\n      }\n    } else {\n      id = source[index++];\n    }\n\n    while (index < length) {\n      ch = source[index];\n\n      if (!isIdentifierPart(ch)) {\n        break;\n      }\n\n      if (ch === '\\\\') {\n        ++index;\n\n        if (source[index] !== 'u') {\n          return;\n        }\n\n        ++index;\n        restore = index;\n        ch = scanHexEscape('u');\n\n        if (ch) {\n          if (ch === '\\\\' || !isIdentifierPart(ch)) {\n            return;\n          }\n\n          id += ch;\n        } else {\n          index = restore;\n          id += 'u';\n        }\n      } else {\n        id += source[index++];\n      }\n    } // There is no keyword or literal with only one character.\n    // Thus, it must be an identifier.\n\n\n    if (id.length === 1) {\n      return {\n        type: Token.Identifier,\n        value: id,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    if (isKeyword(id)) {\n      return {\n        type: Token.Keyword,\n        value: id,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    } // 7.8.1 Null Literals\n\n\n    if (id === 'null') {\n      return {\n        type: Token.NullLiteral,\n        value: id,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    } // 7.8.2 Boolean Literals\n\n\n    if (id === 'true' || id === 'false') {\n      return {\n        type: Token.BooleanLiteral,\n        value: id,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    return {\n      type: Token.Identifier,\n      value: id,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  } // 7.7 Punctuators\n\n\n  function scanPunctuator() {\n    var start = index,\n        ch1 = source[index],\n        ch2,\n        ch3,\n        ch4; // Check for most common single-character punctuators.\n\n    if (ch1 === ';' || ch1 === '{' || ch1 === '}') {\n      ++index;\n      return {\n        type: Token.Punctuator,\n        value: ch1,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    if (ch1 === ',' || ch1 === '(' || ch1 === ')') {\n      ++index;\n      return {\n        type: Token.Punctuator,\n        value: ch1,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    } // Dot (.) can also start a floating-point number, hence the need\n    // to check the next character.\n\n\n    ch2 = source[index + 1];\n\n    if (ch1 === '.' && !isDecimalDigit(ch2)) {\n      return {\n        type: Token.Punctuator,\n        value: source[index++],\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    } // Peek more characters.\n\n\n    ch3 = source[index + 2];\n    ch4 = source[index + 3]; // 4-character punctuator: >>>=\n\n    if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n      if (ch4 === '=') {\n        index += 4;\n        return {\n          type: Token.Punctuator,\n          value: '>>>=',\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          range: [start, index]\n        };\n      }\n    } // 3-character punctuators: === !== >>> <<= >>=\n\n\n    if (ch1 === '=' && ch2 === '=' && ch3 === '=') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '===',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    if (ch1 === '!' && ch2 === '=' && ch3 === '=') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '!==',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '>>>',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '<<=',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n\n    if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: '>>=',\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    } // 2-character punctuators: <= >= == != ++ -- << >> && ||\n    // += -= *= %= &= |= ^= /=\n\n\n    if (ch2 === '=') {\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n        index += 2;\n        return {\n          type: Token.Punctuator,\n          value: ch1 + ch2,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          range: [start, index]\n        };\n      }\n    }\n\n    if (ch1 === ch2 && '+-<>&|'.indexOf(ch1) >= 0) {\n      if ('+-<>&|'.indexOf(ch2) >= 0) {\n        index += 2;\n        return {\n          type: Token.Punctuator,\n          value: ch1 + ch2,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          range: [start, index]\n        };\n      }\n    } // The remaining 1-character punctuators.\n\n\n    if ('[]<>+-*%&|^!~?:=/'.indexOf(ch1) >= 0) {\n      return {\n        type: Token.Punctuator,\n        value: source[index++],\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [start, index]\n      };\n    }\n  } // 7.8.3 Numeric Literals\n\n\n  function scanNumericLiteral() {\n    var number, start, ch;\n    ch = source[index];\n    assert(isDecimalDigit(ch) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');\n    start = index;\n    number = '';\n\n    if (ch !== '.') {\n      number = source[index++];\n      ch = source[index]; // Hex number starts with '0x'.\n      // Octal number starts with '0'.\n\n      if (number === '0') {\n        if (ch === 'x' || ch === 'X') {\n          number += source[index++];\n\n          while (index < length) {\n            ch = source[index];\n\n            if (!isHexDigit(ch)) {\n              break;\n            }\n\n            number += source[index++];\n          }\n\n          if (number.length <= 2) {\n            // only 0x\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n\n          if (index < length) {\n            ch = source[index];\n\n            if (isIdentifierStart(ch)) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n          }\n\n          return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n          };\n        } else if (isOctalDigit(ch)) {\n          number += source[index++];\n\n          while (index < length) {\n            ch = source[index];\n\n            if (!isOctalDigit(ch)) {\n              break;\n            }\n\n            number += source[index++];\n          }\n\n          if (index < length) {\n            ch = source[index];\n\n            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n          }\n\n          return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: true,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n          };\n        } // decimal number starts with '0' such as '09' is illegal.\n\n\n        if (isDecimalDigit(ch)) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n      }\n\n      while (index < length) {\n        ch = source[index];\n\n        if (!isDecimalDigit(ch)) {\n          break;\n        }\n\n        number += source[index++];\n      }\n    }\n\n    if (ch === '.') {\n      number += source[index++];\n\n      while (index < length) {\n        ch = source[index];\n\n        if (!isDecimalDigit(ch)) {\n          break;\n        }\n\n        number += source[index++];\n      }\n    }\n\n    if (ch === 'e' || ch === 'E') {\n      number += source[index++];\n      ch = source[index];\n\n      if (ch === '+' || ch === '-') {\n        number += source[index++];\n      }\n\n      ch = source[index];\n\n      if (isDecimalDigit(ch)) {\n        number += source[index++];\n\n        while (index < length) {\n          ch = source[index];\n\n          if (!isDecimalDigit(ch)) {\n            break;\n          }\n\n          number += source[index++];\n        }\n      } else {\n        ch = 'character ' + ch;\n\n        if (index >= length) {\n          ch = '<end>';\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n    }\n\n    if (index < length) {\n      ch = source[index];\n\n      if (isIdentifierStart(ch)) {\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseFloat(number),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  } // 7.8.4 String Literals\n\n\n  function scanStringLiteral() {\n    var str = '',\n        quote,\n        start,\n        ch,\n        code,\n        unescaped,\n        restore,\n        octal = false;\n    quote = source[index];\n    assert(quote === '\\'' || quote === '\"', 'String literal must starts with a quote');\n    start = index;\n    ++index;\n\n    while (index < length) {\n      ch = source[index++];\n\n      if (ch === quote) {\n        quote = '';\n        break;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n\n        if (!isLineTerminator(ch)) {\n          switch (ch) {\n            case 'n':\n              str += '\\n';\n              break;\n\n            case 'r':\n              str += '\\r';\n              break;\n\n            case 't':\n              str += '\\t';\n              break;\n\n            case 'u':\n            case 'x':\n              restore = index;\n              unescaped = scanHexEscape(ch);\n\n              if (unescaped) {\n                str += unescaped;\n              } else {\n                index = restore;\n                str += ch;\n              }\n\n              break;\n\n            case 'b':\n              str += '\\b';\n              break;\n\n            case 'f':\n              str += '\\f';\n              break;\n\n            case 'v':\n              str += '\\x0B';\n              break;\n\n            default:\n              if (isOctalDigit(ch)) {\n                code = '01234567'.indexOf(ch); // \\0 is not octal escape sequence\n\n                if (code !== 0) {\n                  octal = true;\n                }\n\n                if (index < length && isOctalDigit(source[index])) {\n                  octal = true;\n                  code = code * 8 + '01234567'.indexOf(source[index++]); // 3 digits are only allowed when string starts\n                  // with 0, 1, 2, 3\n\n                  if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                  }\n                }\n\n                str += String.fromCharCode(code);\n              } else {\n                str += ch;\n              }\n\n              break;\n          }\n        } else {\n          ++lineNumber;\n\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n        }\n      } else if (isLineTerminator(ch)) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n\n    if (quote !== '') {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    return {\n      type: Token.StringLiteral,\n      value: str,\n      octal: octal,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      range: [start, index]\n    };\n  }\n\n  function scanRegExp() {\n    var str,\n        ch,\n        start,\n        pattern,\n        flags,\n        value,\n        classMarker = false,\n        restore,\n        terminated = false;\n    buffer = null;\n    skipComment();\n    start = index;\n    ch = source[index];\n    assert(ch === '/', 'Regular expression literal must start with a slash');\n    str = source[index++];\n\n    while (index < length) {\n      ch = source[index++];\n      str += ch;\n\n      if (ch === '\\\\') {\n        ch = source[index++]; // ECMA-262 7.8.5\n\n        if (isLineTerminator(ch)) {\n          throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        str += ch;\n      } else if (classMarker) {\n        if (ch === ']') {\n          classMarker = false;\n        }\n      } else {\n        if (ch === '/') {\n          terminated = true;\n          break;\n        } else if (ch === '[') {\n          classMarker = true;\n        } else if (isLineTerminator(ch)) {\n          throwError({}, Messages.UnterminatedRegExp);\n        }\n      }\n    }\n\n    if (!terminated) {\n      throwError({}, Messages.UnterminatedRegExp);\n    } // Exclude leading and trailing slash.\n\n\n    pattern = str.substr(1, str.length - 2);\n    flags = '';\n\n    while (index < length) {\n      ch = source[index];\n\n      if (!isIdentifierPart(ch)) {\n        break;\n      }\n\n      ++index;\n\n      if (ch === '\\\\' && index < length) {\n        ch = source[index];\n\n        if (ch === 'u') {\n          ++index;\n          restore = index;\n          ch = scanHexEscape('u');\n\n          if (ch) {\n            flags += ch;\n            str += '\\\\u';\n\n            for (; restore < index; ++restore) {\n              str += source[restore];\n            }\n          } else {\n            index = restore;\n            flags += 'u';\n            str += '\\\\u';\n          }\n        } else {\n          str += '\\\\';\n        }\n      } else {\n        flags += ch;\n        str += ch;\n      }\n    }\n\n    try {\n      value = new RegExp(pattern, flags);\n    } catch (e) {\n      throwError({}, Messages.InvalidRegExp);\n    }\n\n    return {\n      literal: str,\n      value: value,\n      range: [start, index]\n    };\n  }\n\n  function isIdentifierName(token) {\n    return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;\n  }\n\n  function advance() {\n    var ch, token;\n    skipComment();\n\n    if (index >= length) {\n      return {\n        type: Token.EOF,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        range: [index, index]\n      };\n    }\n\n    token = scanPunctuator();\n\n    if (typeof token !== 'undefined') {\n      return token;\n    }\n\n    ch = source[index];\n\n    if (ch === '\\'' || ch === '\"') {\n      return scanStringLiteral();\n    }\n\n    if (ch === '.' || isDecimalDigit(ch)) {\n      return scanNumericLiteral();\n    }\n\n    token = scanIdentifier();\n\n    if (typeof token !== 'undefined') {\n      return token;\n    }\n\n    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  function lex() {\n    var token;\n\n    if (buffer) {\n      index = buffer.range[1];\n      lineNumber = buffer.lineNumber;\n      lineStart = buffer.lineStart;\n      token = buffer;\n      buffer = null;\n      return token;\n    }\n\n    buffer = null;\n    return advance();\n  }\n\n  function lookahead() {\n    var pos, line, start;\n\n    if (buffer !== null) {\n      return buffer;\n    }\n\n    pos = index;\n    line = lineNumber;\n    start = lineStart;\n    buffer = advance();\n    index = pos;\n    lineNumber = line;\n    lineStart = start;\n    return buffer;\n  } // Return true if there is a line terminator before the next token.\n\n\n  function peekLineTerminator() {\n    var pos, line, start, found;\n    pos = index;\n    line = lineNumber;\n    start = lineStart;\n    skipComment();\n    found = lineNumber !== line;\n    index = pos;\n    lineNumber = line;\n    lineStart = start;\n    return found;\n  } // Throw an exception\n\n\n  function throwError(token, messageFormat) {\n    var error,\n        args = Array.prototype.slice.call(arguments, 2),\n        msg = messageFormat.replace(/%(\\d)/g, function (whole, index) {\n      return args[index] || '';\n    });\n\n    if (typeof token.lineNumber === 'number') {\n      error = new Error('Line ' + token.lineNumber + ': ' + msg);\n      error.index = token.range[0];\n      error.lineNumber = token.lineNumber;\n      error.column = token.range[0] - lineStart + 1;\n    } else {\n      error = new Error('Line ' + lineNumber + ': ' + msg);\n      error.index = index;\n      error.lineNumber = lineNumber;\n      error.column = index - lineStart + 1;\n    }\n\n    throw error;\n  }\n\n  function throwErrorTolerant() {\n    try {\n      throwError.apply(null, arguments);\n    } catch (e) {\n      if (extra.errors) {\n        extra.errors.push(e);\n      } else {\n        throw e;\n      }\n    }\n  } // Throw an exception because of the token.\n\n\n  function throwUnexpected(token) {\n    if (token.type === Token.EOF) {\n      throwError(token, Messages.UnexpectedEOS);\n    }\n\n    if (token.type === Token.NumericLiteral) {\n      throwError(token, Messages.UnexpectedNumber);\n    }\n\n    if (token.type === Token.StringLiteral) {\n      throwError(token, Messages.UnexpectedString);\n    }\n\n    if (token.type === Token.Identifier) {\n      throwError(token, Messages.UnexpectedIdentifier);\n    }\n\n    if (token.type === Token.Keyword) {\n      if (isFutureReservedWord(token.value)) {\n        throwError(token, Messages.UnexpectedReserved);\n      } else if (strict && isStrictModeReservedWord(token.value)) {\n        throwErrorTolerant(token, Messages.StrictReservedWord);\n        return;\n      }\n\n      throwError(token, Messages.UnexpectedToken, token.value);\n    } // BooleanLiteral, NullLiteral, or Punctuator.\n\n\n    throwError(token, Messages.UnexpectedToken, token.value);\n  } // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n\n  function expect(value) {\n    var token = lex();\n\n    if (token.type !== Token.Punctuator || token.value !== value) {\n      throwUnexpected(token);\n    }\n  } // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n\n  function expectKeyword(keyword) {\n    var token = lex();\n\n    if (token.type !== Token.Keyword || token.value !== keyword) {\n      throwUnexpected(token);\n    }\n  } // Return true if the next token matches the specified punctuator.\n\n\n  function match(value) {\n    var token = lookahead();\n    return token.type === Token.Punctuator && token.value === value;\n  } // Return true if the next token matches the specified keyword\n\n\n  function matchKeyword(keyword) {\n    var token = lookahead();\n    return token.type === Token.Keyword && token.value === keyword;\n  } // Return true if the next token is an assignment operator\n\n\n  function matchAssign() {\n    var token = lookahead(),\n        op = token.value;\n\n    if (token.type !== Token.Punctuator) {\n      return false;\n    }\n\n    return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';\n  }\n\n  function consumeSemicolon() {\n    var token, line; // Catch the very common case first.\n\n    if (source[index] === ';') {\n      lex();\n      return;\n    }\n\n    line = lineNumber;\n    skipComment();\n\n    if (lineNumber !== line) {\n      return;\n    }\n\n    if (match(';')) {\n      lex();\n      return;\n    }\n\n    token = lookahead();\n\n    if (token.type !== Token.EOF && !match('}')) {\n      throwUnexpected(token);\n    }\n  } // Return true if provided expression is LeftHandSideExpression\n\n\n  function isLeftHandSide(expr) {\n    return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  } // 11.1.4 Array Initialiser\n\n\n  function parseArrayInitialiser() {\n    var elements = [];\n    expect('[');\n\n    while (!match(']')) {\n      if (match(',')) {\n        lex();\n        elements.push(null);\n      } else {\n        elements.push(parseAssignmentExpression());\n\n        if (!match(']')) {\n          expect(',');\n        }\n      }\n    }\n\n    expect(']');\n    return {\n      type: Syntax.ArrayExpression,\n      elements: elements\n    };\n  } // 11.1.5 Object Initialiser\n\n\n  function parsePropertyFunction(param, first) {\n    var previousStrict, body;\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n\n    if (first && strict && isRestrictedWord(param[0].name)) {\n      throwErrorTolerant(first, Messages.StrictParamName);\n    }\n\n    strict = previousStrict;\n    return {\n      type: Syntax.FunctionExpression,\n      id: null,\n      params: param,\n      defaults: [],\n      body: body,\n      rest: null,\n      generator: false,\n      expression: false\n    };\n  }\n\n  function parseObjectPropertyKey() {\n    var token = lex(); // Note: This function is called only from parseObjectProperty(), where\n    // EOF and Punctuator tokens are already filtered out.\n\n    if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n      if (strict && token.octal) {\n        throwErrorTolerant(token, Messages.StrictOctalLiteral);\n      }\n\n      return createLiteral(token);\n    }\n\n    return {\n      type: Syntax.Identifier,\n      name: token.value\n    };\n  }\n\n  function parseObjectProperty() {\n    var token, key, id, param;\n    token = lookahead();\n\n    if (token.type === Token.Identifier) {\n      id = parseObjectPropertyKey(); // Property Assignment: Getter and Setter.\n\n      if (token.value === 'get' && !match(':')) {\n        key = parseObjectPropertyKey();\n        expect('(');\n        expect(')');\n        return {\n          type: Syntax.Property,\n          key: key,\n          value: parsePropertyFunction([]),\n          kind: 'get'\n        };\n      } else if (token.value === 'set' && !match(':')) {\n        key = parseObjectPropertyKey();\n        expect('(');\n        token = lookahead();\n\n        if (token.type !== Token.Identifier) {\n          expect(')');\n          throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          return {\n            type: Syntax.Property,\n            key: key,\n            value: parsePropertyFunction([]),\n            kind: 'set'\n          };\n        } else {\n          param = [parseVariableIdentifier()];\n          expect(')');\n          return {\n            type: Syntax.Property,\n            key: key,\n            value: parsePropertyFunction(param, token),\n            kind: 'set'\n          };\n        }\n      } else {\n        expect(':');\n        return {\n          type: Syntax.Property,\n          key: id,\n          value: parseAssignmentExpression(),\n          kind: 'init'\n        };\n      }\n    } else if (token.type === Token.EOF || token.type === Token.Punctuator) {\n      throwUnexpected(token);\n    } else {\n      key = parseObjectPropertyKey();\n      expect(':');\n      return {\n        type: Syntax.Property,\n        key: key,\n        value: parseAssignmentExpression(),\n        kind: 'init'\n      };\n    }\n  }\n\n  function parseObjectInitialiser() {\n    var properties = [],\n        property,\n        name,\n        kind,\n        map = {},\n        toString = String;\n    expect('{');\n\n    while (!match('}')) {\n      property = parseObjectProperty();\n\n      if (property.key.type === Syntax.Identifier) {\n        name = property.key.name;\n      } else {\n        name = toString(property.key.value);\n      }\n\n      kind = property.kind === 'init' ? PropertyKind.Data : property.kind === 'get' ? PropertyKind.Get : PropertyKind.Set;\n\n      if (Object.prototype.hasOwnProperty.call(map, name)) {\n        if (map[name] === PropertyKind.Data) {\n          if (strict && kind === PropertyKind.Data) {\n            throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n          } else if (kind !== PropertyKind.Data) {\n            throwErrorTolerant({}, Messages.AccessorDataProperty);\n          }\n        } else {\n          if (kind === PropertyKind.Data) {\n            throwErrorTolerant({}, Messages.AccessorDataProperty);\n          } else if (map[name] & kind) {\n            throwErrorTolerant({}, Messages.AccessorGetSet);\n          }\n        }\n\n        map[name] |= kind;\n      } else {\n        map[name] = kind;\n      }\n\n      properties.push(property);\n\n      if (!match('}')) {\n        expect(',');\n      }\n    }\n\n    expect('}');\n    return {\n      type: Syntax.ObjectExpression,\n      properties: properties\n    };\n  } // 11.1.6 The Grouping Operator\n\n\n  function parseGroupExpression() {\n    var expr;\n    expect('(');\n    expr = parseExpression();\n    expect(')');\n    return expr;\n  } // 11.1 Primary Expressions\n\n\n  function parsePrimaryExpression() {\n    var token = lookahead(),\n        type = token.type;\n\n    if (type === Token.Identifier) {\n      return {\n        type: Syntax.Identifier,\n        name: lex().value\n      };\n    }\n\n    if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n      if (strict && token.octal) {\n        throwErrorTolerant(token, Messages.StrictOctalLiteral);\n      }\n\n      return createLiteral(lex());\n    }\n\n    if (type === Token.Keyword) {\n      if (matchKeyword('this')) {\n        lex();\n        return {\n          type: Syntax.ThisExpression\n        };\n      }\n\n      if (matchKeyword('function')) {\n        return parseFunctionExpression();\n      }\n    }\n\n    if (type === Token.BooleanLiteral) {\n      lex();\n      token.value = token.value === 'true';\n      return createLiteral(token);\n    }\n\n    if (type === Token.NullLiteral) {\n      lex();\n      token.value = null;\n      return createLiteral(token);\n    }\n\n    if (match('[')) {\n      return parseArrayInitialiser();\n    }\n\n    if (match('{')) {\n      return parseObjectInitialiser();\n    }\n\n    if (match('(')) {\n      return parseGroupExpression();\n    }\n\n    if (match('/') || match('/=')) {\n      return createLiteral(scanRegExp());\n    }\n\n    return throwUnexpected(lex());\n  } // 11.2 Left-Hand-Side Expressions\n\n\n  function parseArguments() {\n    var args = [];\n    expect('(');\n\n    if (!match(')')) {\n      while (index < length) {\n        args.push(parseAssignmentExpression());\n\n        if (match(')')) {\n          break;\n        }\n\n        expect(',');\n      }\n    }\n\n    expect(')');\n    return args;\n  }\n\n  function parseNonComputedProperty() {\n    var token = lex();\n\n    if (!isIdentifierName(token)) {\n      throwUnexpected(token);\n    }\n\n    return {\n      type: Syntax.Identifier,\n      name: token.value\n    };\n  }\n\n  function parseNonComputedMember() {\n    expect('.');\n    return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n    var expr;\n    expect('[');\n    expr = parseExpression();\n    expect(']');\n    return expr;\n  }\n\n  function parseNewExpression() {\n    var expr;\n    expectKeyword('new');\n    expr = {\n      type: Syntax.NewExpression,\n      callee: parseLeftHandSideExpression(),\n      'arguments': []\n    };\n\n    if (match('(')) {\n      expr['arguments'] = parseArguments();\n    }\n\n    return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n    var expr;\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n    while (match('.') || match('[') || match('(')) {\n      if (match('(')) {\n        expr = {\n          type: Syntax.CallExpression,\n          callee: expr,\n          'arguments': parseArguments()\n        };\n      } else if (match('[')) {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: true,\n          object: expr,\n          property: parseComputedMember()\n        };\n      } else {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: false,\n          object: expr,\n          property: parseNonComputedMember()\n        };\n      }\n    }\n\n    return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n    var expr;\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n    while (match('.') || match('[')) {\n      if (match('[')) {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: true,\n          object: expr,\n          property: parseComputedMember()\n        };\n      } else {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: false,\n          object: expr,\n          property: parseNonComputedMember()\n        };\n      }\n    }\n\n    return expr;\n  } // 11.3 Postfix Expressions\n\n\n  function parsePostfixExpression() {\n    var expr = parseLeftHandSideExpressionAllowCall(),\n        token;\n    token = lookahead();\n\n    if (token.type !== Token.Punctuator) {\n      return expr;\n    }\n\n    if ((match('++') || match('--')) && !peekLineTerminator()) {\n      // 11.3.1, 11.3.2\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        throwErrorTolerant({}, Messages.StrictLHSPostfix);\n      }\n\n      if (!isLeftHandSide(expr)) {\n        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n      }\n\n      expr = {\n        type: Syntax.UpdateExpression,\n        operator: lex().value,\n        argument: expr,\n        prefix: false\n      };\n    }\n\n    return expr;\n  } // 11.4 Unary Operators\n\n\n  function parseUnaryExpression() {\n    var token, expr;\n    token = lookahead();\n\n    if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n      return parsePostfixExpression();\n    }\n\n    if (match('++') || match('--')) {\n      token = lex();\n      expr = parseUnaryExpression(); // 11.4.4, 11.4.5\n\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        throwErrorTolerant({}, Messages.StrictLHSPrefix);\n      }\n\n      if (!isLeftHandSide(expr)) {\n        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n      }\n\n      expr = {\n        type: Syntax.UpdateExpression,\n        operator: token.value,\n        argument: expr,\n        prefix: true\n      };\n      return expr;\n    }\n\n    if (match('+') || match('-') || match('~') || match('!')) {\n      expr = {\n        type: Syntax.UnaryExpression,\n        operator: lex().value,\n        argument: parseUnaryExpression(),\n        prefix: true\n      };\n      return expr;\n    }\n\n    if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n      expr = {\n        type: Syntax.UnaryExpression,\n        operator: lex().value,\n        argument: parseUnaryExpression(),\n        prefix: true\n      };\n\n      if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n        throwErrorTolerant({}, Messages.StrictDelete);\n      }\n\n      return expr;\n    }\n\n    return parsePostfixExpression();\n  } // 11.5 Multiplicative Operators\n\n\n  function parseMultiplicativeExpression() {\n    var expr = parseUnaryExpression();\n\n    while (match('*') || match('/') || match('%')) {\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: lex().value,\n        left: expr,\n        right: parseUnaryExpression()\n      };\n    }\n\n    return expr;\n  } // 11.6 Additive Operators\n\n\n  function parseAdditiveExpression() {\n    var expr = parseMultiplicativeExpression();\n\n    while (match('+') || match('-')) {\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: lex().value,\n        left: expr,\n        right: parseMultiplicativeExpression()\n      };\n    }\n\n    return expr;\n  } // 11.7 Bitwise Shift Operators\n\n\n  function parseShiftExpression() {\n    var expr = parseAdditiveExpression();\n\n    while (match('<<') || match('>>') || match('>>>')) {\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: lex().value,\n        left: expr,\n        right: parseAdditiveExpression()\n      };\n    }\n\n    return expr;\n  } // 11.8 Relational Operators\n\n\n  function parseRelationalExpression() {\n    var expr, previousAllowIn;\n    previousAllowIn = state.allowIn;\n    state.allowIn = true;\n    expr = parseShiftExpression();\n\n    while (match('<') || match('>') || match('<=') || match('>=') || previousAllowIn && matchKeyword('in') || matchKeyword('instanceof')) {\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: lex().value,\n        left: expr,\n        right: parseShiftExpression()\n      };\n    }\n\n    state.allowIn = previousAllowIn;\n    return expr;\n  } // 11.9 Equality Operators\n\n\n  function parseEqualityExpression() {\n    var expr = parseRelationalExpression();\n\n    while (match('==') || match('!=') || match('===') || match('!==')) {\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: lex().value,\n        left: expr,\n        right: parseRelationalExpression()\n      };\n    }\n\n    return expr;\n  } // 11.10 Binary Bitwise Operators\n\n\n  function parseBitwiseANDExpression() {\n    var expr = parseEqualityExpression();\n\n    while (match('&')) {\n      lex();\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: '&',\n        left: expr,\n        right: parseEqualityExpression()\n      };\n    }\n\n    return expr;\n  }\n\n  function parseBitwiseXORExpression() {\n    var expr = parseBitwiseANDExpression();\n\n    while (match('^')) {\n      lex();\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: '^',\n        left: expr,\n        right: parseBitwiseANDExpression()\n      };\n    }\n\n    return expr;\n  }\n\n  function parseBitwiseORExpression() {\n    var expr = parseBitwiseXORExpression();\n\n    while (match('|')) {\n      lex();\n      expr = {\n        type: Syntax.BinaryExpression,\n        operator: '|',\n        left: expr,\n        right: parseBitwiseXORExpression()\n      };\n    }\n\n    return expr;\n  } // 11.11 Binary Logical Operators\n\n\n  function parseLogicalANDExpression() {\n    var expr = parseBitwiseORExpression();\n\n    while (match('&&')) {\n      lex();\n      expr = {\n        type: Syntax.LogicalExpression,\n        operator: '&&',\n        left: expr,\n        right: parseBitwiseORExpression()\n      };\n    }\n\n    return expr;\n  }\n\n  function parseLogicalORExpression() {\n    var expr = parseLogicalANDExpression();\n\n    while (match('||')) {\n      lex();\n      expr = {\n        type: Syntax.LogicalExpression,\n        operator: '||',\n        left: expr,\n        right: parseLogicalANDExpression()\n      };\n    }\n\n    return expr;\n  } // 11.12 Conditional Operator\n\n\n  function parseConditionalExpression() {\n    var expr, previousAllowIn, consequent;\n    expr = parseLogicalORExpression();\n\n    if (match('?')) {\n      lex();\n      previousAllowIn = state.allowIn;\n      state.allowIn = true;\n      consequent = parseAssignmentExpression();\n      state.allowIn = previousAllowIn;\n      expect(':');\n      expr = {\n        type: Syntax.ConditionalExpression,\n        test: expr,\n        consequent: consequent,\n        alternate: parseAssignmentExpression()\n      };\n    }\n\n    return expr;\n  } // 11.13 Assignment Operators\n\n\n  function parseAssignmentExpression() {\n    var token, expr;\n    token = lookahead();\n    expr = parseConditionalExpression();\n\n    if (matchAssign()) {\n      // LeftHandSideExpression\n      if (!isLeftHandSide(expr)) {\n        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n      } // 11.13.1\n\n\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        throwErrorTolerant(token, Messages.StrictLHSAssignment);\n      }\n\n      expr = {\n        type: Syntax.AssignmentExpression,\n        operator: lex().value,\n        left: expr,\n        right: parseAssignmentExpression()\n      };\n    }\n\n    return expr;\n  } // 11.14 Comma Operator\n\n\n  function parseExpression() {\n    var expr = parseAssignmentExpression();\n\n    if (match(',')) {\n      expr = {\n        type: Syntax.SequenceExpression,\n        expressions: [expr]\n      };\n\n      while (index < length) {\n        if (!match(',')) {\n          break;\n        }\n\n        lex();\n        expr.expressions.push(parseAssignmentExpression());\n      }\n    }\n\n    return expr;\n  } // 12.1 Block\n\n\n  function parseStatementList() {\n    var list = [],\n        statement;\n\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n\n      statement = parseSourceElement();\n\n      if (typeof statement === 'undefined') {\n        break;\n      }\n\n      list.push(statement);\n    }\n\n    return list;\n  }\n\n  function parseBlock() {\n    var block;\n    expect('{');\n    block = parseStatementList();\n    expect('}');\n    return {\n      type: Syntax.BlockStatement,\n      body: block\n    };\n  } // 12.2 Variable Statement\n\n\n  function parseVariableIdentifier() {\n    var token = lex();\n\n    if (token.type !== Token.Identifier) {\n      throwUnexpected(token);\n    }\n\n    return {\n      type: Syntax.Identifier,\n      name: token.value\n    };\n  }\n\n  function parseVariableDeclaration(kind) {\n    var id = parseVariableIdentifier(),\n        init = null; // 12.2.1\n\n    if (strict && isRestrictedWord(id.name)) {\n      throwErrorTolerant({}, Messages.StrictVarName);\n    }\n\n    if (kind === 'const') {\n      expect('=');\n      init = parseAssignmentExpression();\n    } else if (match('=')) {\n      lex();\n      init = parseAssignmentExpression();\n    }\n\n    return {\n      type: Syntax.VariableDeclarator,\n      id: id,\n      init: init\n    };\n  }\n\n  function parseVariableDeclarationList(kind) {\n    var list = [];\n\n    do {\n      list.push(parseVariableDeclaration(kind));\n\n      if (!match(',')) {\n        break;\n      }\n\n      lex();\n    } while (index < length);\n\n    return list;\n  }\n\n  function parseVariableStatement() {\n    var declarations;\n    expectKeyword('var');\n    declarations = parseVariableDeclarationList();\n    consumeSemicolon();\n    return {\n      type: Syntax.VariableDeclaration,\n      declarations: declarations,\n      kind: 'var'\n    };\n  } // kind may be `const` or `let`\n  // Both are experimental and not in the specification yet.\n  // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n  // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n\n\n  function parseConstLetDeclaration(kind) {\n    var declarations;\n    expectKeyword(kind);\n    declarations = parseVariableDeclarationList(kind);\n    consumeSemicolon();\n    return {\n      type: Syntax.VariableDeclaration,\n      declarations: declarations,\n      kind: kind\n    };\n  } // 12.3 Empty Statement\n\n\n  function parseEmptyStatement() {\n    expect(';');\n    return {\n      type: Syntax.EmptyStatement\n    };\n  } // 12.4 Expression Statement\n\n\n  function parseExpressionStatement() {\n    var expr = parseExpression();\n    consumeSemicolon();\n    return {\n      type: Syntax.ExpressionStatement,\n      expression: expr\n    };\n  } // 12.5 If statement\n\n\n  function parseIfStatement() {\n    var test, consequent, alternate;\n    expectKeyword('if');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    consequent = parseStatement();\n\n    if (matchKeyword('else')) {\n      lex();\n      alternate = parseStatement();\n    } else {\n      alternate = null;\n    }\n\n    return {\n      type: Syntax.IfStatement,\n      test: test,\n      consequent: consequent,\n      alternate: alternate\n    };\n  } // 12.6 Iteration Statements\n\n\n  function parseDoWhileStatement() {\n    var body, test, oldInIteration;\n    expectKeyword('do');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n\n    if (match(';')) {\n      lex();\n    }\n\n    return {\n      type: Syntax.DoWhileStatement,\n      body: body,\n      test: test\n    };\n  }\n\n  function parseWhileStatement() {\n    var test, body, oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    return {\n      type: Syntax.WhileStatement,\n      test: test,\n      body: body\n    };\n  }\n\n  function parseForVariableDeclaration() {\n    var token = lex();\n    return {\n      type: Syntax.VariableDeclaration,\n      declarations: parseVariableDeclarationList(),\n      kind: token.value\n    };\n  }\n\n  function parseForStatement() {\n    var init, test, update, left, right, body, oldInIteration;\n    init = test = update = null;\n    expectKeyword('for');\n    expect('(');\n\n    if (match(';')) {\n      lex();\n    } else {\n      if (matchKeyword('var') || matchKeyword('let')) {\n        state.allowIn = false;\n        init = parseForVariableDeclaration();\n        state.allowIn = true;\n\n        if (init.declarations.length === 1 && matchKeyword('in')) {\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        }\n      } else {\n        state.allowIn = false;\n        init = parseExpression();\n        state.allowIn = true;\n\n        if (matchKeyword('in')) {\n          // LeftHandSideExpression\n          if (!isLeftHandSide(init)) {\n            throwErrorTolerant({}, Messages.InvalidLHSInForIn);\n          }\n\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        }\n      }\n\n      if (typeof left === 'undefined') {\n        expect(';');\n      }\n    }\n\n    if (typeof left === 'undefined') {\n      if (!match(';')) {\n        test = parseExpression();\n      }\n\n      expect(';');\n\n      if (!match(')')) {\n        update = parseExpression();\n      }\n    }\n\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n\n    if (typeof left === 'undefined') {\n      return {\n        type: Syntax.ForStatement,\n        init: init,\n        test: test,\n        update: update,\n        body: body\n      };\n    }\n\n    return {\n      type: Syntax.ForInStatement,\n      left: left,\n      right: right,\n      body: body,\n      each: false\n    };\n  } // 12.7 The continue statement\n\n\n  function parseContinueStatement() {\n    var token,\n        label = null;\n    expectKeyword('continue'); // Optimize the most common form: 'continue;'.\n\n    if (source[index] === ';') {\n      lex();\n\n      if (!state.inIteration) {\n        throwError({}, Messages.IllegalContinue);\n      }\n\n      return {\n        type: Syntax.ContinueStatement,\n        label: null\n      };\n    }\n\n    if (peekLineTerminator()) {\n      if (!state.inIteration) {\n        throwError({}, Messages.IllegalContinue);\n      }\n\n      return {\n        type: Syntax.ContinueStatement,\n        label: null\n      };\n    }\n\n    token = lookahead();\n\n    if (token.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {\n        throwError({}, Messages.UnknownLabel, label.name);\n      }\n    }\n\n    consumeSemicolon();\n\n    if (label === null && !state.inIteration) {\n      throwError({}, Messages.IllegalContinue);\n    }\n\n    return {\n      type: Syntax.ContinueStatement,\n      label: label\n    };\n  } // 12.8 The break statement\n\n\n  function parseBreakStatement() {\n    var token,\n        label = null;\n    expectKeyword('break'); // Optimize the most common form: 'break;'.\n\n    if (source[index] === ';') {\n      lex();\n\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError({}, Messages.IllegalBreak);\n      }\n\n      return {\n        type: Syntax.BreakStatement,\n        label: null\n      };\n    }\n\n    if (peekLineTerminator()) {\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError({}, Messages.IllegalBreak);\n      }\n\n      return {\n        type: Syntax.BreakStatement,\n        label: null\n      };\n    }\n\n    token = lookahead();\n\n    if (token.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {\n        throwError({}, Messages.UnknownLabel, label.name);\n      }\n    }\n\n    consumeSemicolon();\n\n    if (label === null && !(state.inIteration || state.inSwitch)) {\n      throwError({}, Messages.IllegalBreak);\n    }\n\n    return {\n      type: Syntax.BreakStatement,\n      label: label\n    };\n  } // 12.9 The return statement\n\n\n  function parseReturnStatement() {\n    var token,\n        argument = null;\n    expectKeyword('return');\n\n    if (!state.inFunctionBody) {\n      throwErrorTolerant({}, Messages.IllegalReturn);\n    } // 'return' followed by a space and an identifier is very common.\n\n\n    if (source[index] === ' ') {\n      if (isIdentifierStart(source[index + 1])) {\n        argument = parseExpression();\n        consumeSemicolon();\n        return {\n          type: Syntax.ReturnStatement,\n          argument: argument\n        };\n      }\n    }\n\n    if (peekLineTerminator()) {\n      return {\n        type: Syntax.ReturnStatement,\n        argument: null\n      };\n    }\n\n    if (!match(';')) {\n      token = lookahead();\n\n      if (!match('}') && token.type !== Token.EOF) {\n        argument = parseExpression();\n      }\n    }\n\n    consumeSemicolon();\n    return {\n      type: Syntax.ReturnStatement,\n      argument: argument\n    };\n  } // 12.10 The with statement\n\n\n  function parseWithStatement() {\n    var object, body;\n\n    if (strict) {\n      throwErrorTolerant({}, Messages.StrictModeWith);\n    }\n\n    expectKeyword('with');\n    expect('(');\n    object = parseExpression();\n    expect(')');\n    body = parseStatement();\n    return {\n      type: Syntax.WithStatement,\n      object: object,\n      body: body\n    };\n  } // 12.10 The swith statement\n\n\n  function parseSwitchCase() {\n    var test,\n        consequent = [],\n        statement;\n\n    if (matchKeyword('default')) {\n      lex();\n      test = null;\n    } else {\n      expectKeyword('case');\n      test = parseExpression();\n    }\n\n    expect(':');\n\n    while (index < length) {\n      if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n        break;\n      }\n\n      statement = parseStatement();\n\n      if (typeof statement === 'undefined') {\n        break;\n      }\n\n      consequent.push(statement);\n    }\n\n    return {\n      type: Syntax.SwitchCase,\n      test: test,\n      consequent: consequent\n    };\n  }\n\n  function parseSwitchStatement() {\n    var discriminant, cases, clause, oldInSwitch, defaultFound;\n    expectKeyword('switch');\n    expect('(');\n    discriminant = parseExpression();\n    expect(')');\n    expect('{');\n    cases = [];\n\n    if (match('}')) {\n      lex();\n      return {\n        type: Syntax.SwitchStatement,\n        discriminant: discriminant,\n        cases: cases\n      };\n    }\n\n    oldInSwitch = state.inSwitch;\n    state.inSwitch = true;\n    defaultFound = false;\n\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n\n      clause = parseSwitchCase();\n\n      if (clause.test === null) {\n        if (defaultFound) {\n          throwError({}, Messages.MultipleDefaultsInSwitch);\n        }\n\n        defaultFound = true;\n      }\n\n      cases.push(clause);\n    }\n\n    state.inSwitch = oldInSwitch;\n    expect('}');\n    return {\n      type: Syntax.SwitchStatement,\n      discriminant: discriminant,\n      cases: cases\n    };\n  } // 12.13 The throw statement\n\n\n  function parseThrowStatement() {\n    var argument;\n    expectKeyword('throw');\n\n    if (peekLineTerminator()) {\n      throwError({}, Messages.NewlineAfterThrow);\n    }\n\n    argument = parseExpression();\n    consumeSemicolon();\n    return {\n      type: Syntax.ThrowStatement,\n      argument: argument\n    };\n  } // 12.14 The try statement\n\n\n  function parseCatchClause() {\n    var param;\n    expectKeyword('catch');\n    expect('(');\n\n    if (match(')')) {\n      throwUnexpected(lookahead());\n    }\n\n    param = parseVariableIdentifier(); // 12.14.1\n\n    if (strict && isRestrictedWord(param.name)) {\n      throwErrorTolerant({}, Messages.StrictCatchVariable);\n    }\n\n    expect(')');\n    return {\n      type: Syntax.CatchClause,\n      param: param,\n      body: parseBlock()\n    };\n  }\n\n  function parseTryStatement() {\n    var block,\n        handlers = [],\n        finalizer = null;\n    expectKeyword('try');\n    block = parseBlock();\n\n    if (matchKeyword('catch')) {\n      handlers.push(parseCatchClause());\n    }\n\n    if (matchKeyword('finally')) {\n      lex();\n      finalizer = parseBlock();\n    }\n\n    if (handlers.length === 0 && !finalizer) {\n      throwError({}, Messages.NoCatchOrFinally);\n    }\n\n    return {\n      type: Syntax.TryStatement,\n      block: block,\n      guardedHandlers: [],\n      handlers: handlers,\n      finalizer: finalizer\n    };\n  } // 12.15 The debugger statement\n\n\n  function parseDebuggerStatement() {\n    expectKeyword('debugger');\n    consumeSemicolon();\n    return {\n      type: Syntax.DebuggerStatement\n    };\n  } // 12 Statements\n\n\n  function parseStatement() {\n    var token = lookahead(),\n        expr,\n        labeledBody;\n\n    if (token.type === Token.EOF) {\n      throwUnexpected(token);\n    }\n\n    if (token.type === Token.Punctuator) {\n      switch (token.value) {\n        case ';':\n          return parseEmptyStatement();\n\n        case '{':\n          return parseBlock();\n\n        case '(':\n          return parseExpressionStatement();\n\n        default:\n          break;\n      }\n    }\n\n    if (token.type === Token.Keyword) {\n      switch (token.value) {\n        case 'break':\n          return parseBreakStatement();\n\n        case 'continue':\n          return parseContinueStatement();\n\n        case 'debugger':\n          return parseDebuggerStatement();\n\n        case 'do':\n          return parseDoWhileStatement();\n\n        case 'for':\n          return parseForStatement();\n\n        case 'function':\n          return parseFunctionDeclaration();\n\n        case 'if':\n          return parseIfStatement();\n\n        case 'return':\n          return parseReturnStatement();\n\n        case 'switch':\n          return parseSwitchStatement();\n\n        case 'throw':\n          return parseThrowStatement();\n\n        case 'try':\n          return parseTryStatement();\n\n        case 'var':\n          return parseVariableStatement();\n\n        case 'while':\n          return parseWhileStatement();\n\n        case 'with':\n          return parseWithStatement();\n\n        default:\n          break;\n      }\n    }\n\n    expr = parseExpression(); // 12.12 Labelled Statements\n\n    if (expr.type === Syntax.Identifier && match(':')) {\n      lex();\n\n      if (Object.prototype.hasOwnProperty.call(state.labelSet, expr.name)) {\n        throwError({}, Messages.Redeclaration, 'Label', expr.name);\n      }\n\n      state.labelSet[expr.name] = true;\n      labeledBody = parseStatement();\n      delete state.labelSet[expr.name];\n      return {\n        type: Syntax.LabeledStatement,\n        label: expr,\n        body: labeledBody\n      };\n    }\n\n    consumeSemicolon();\n    return {\n      type: Syntax.ExpressionStatement,\n      expression: expr\n    };\n  } // 13 Function Definition\n\n\n  function parseFunctionSourceElements() {\n    var sourceElement,\n        sourceElements = [],\n        token,\n        directive,\n        firstRestricted,\n        oldLabelSet,\n        oldInIteration,\n        oldInSwitch,\n        oldInFunctionBody;\n    expect('{');\n\n    while (index < length) {\n      token = lookahead();\n\n      if (token.type !== Token.StringLiteral) {\n        break;\n      }\n\n      sourceElement = parseSourceElement();\n      sourceElements.push(sourceElement);\n\n      if (sourceElement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n\n      directive = sliceSource(token.range[0] + 1, token.range[1] - 1);\n\n      if (directive === 'use strict') {\n        strict = true;\n\n        if (firstRestricted) {\n          throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n\n    oldLabelSet = state.labelSet;\n    oldInIteration = state.inIteration;\n    oldInSwitch = state.inSwitch;\n    oldInFunctionBody = state.inFunctionBody;\n    state.labelSet = {};\n    state.inIteration = false;\n    state.inSwitch = false;\n    state.inFunctionBody = true;\n\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n\n      sourceElement = parseSourceElement();\n\n      if (typeof sourceElement === 'undefined') {\n        break;\n      }\n\n      sourceElements.push(sourceElement);\n    }\n\n    expect('}');\n    state.labelSet = oldLabelSet;\n    state.inIteration = oldInIteration;\n    state.inSwitch = oldInSwitch;\n    state.inFunctionBody = oldInFunctionBody;\n    return {\n      type: Syntax.BlockStatement,\n      body: sourceElements\n    };\n  }\n\n  function parseFunctionDeclaration() {\n    var id,\n        param,\n        params = [],\n        body,\n        token,\n        stricted,\n        firstRestricted,\n        message,\n        previousStrict,\n        paramSet;\n    expectKeyword('function');\n    token = lookahead();\n    id = parseVariableIdentifier();\n\n    if (strict) {\n      if (isRestrictedWord(token.value)) {\n        throwErrorTolerant(token, Messages.StrictFunctionName);\n      }\n    } else {\n      if (isRestrictedWord(token.value)) {\n        firstRestricted = token;\n        message = Messages.StrictFunctionName;\n      } else if (isStrictModeReservedWord(token.value)) {\n        firstRestricted = token;\n        message = Messages.StrictReservedWord;\n      }\n    }\n\n    expect('(');\n\n    if (!match(')')) {\n      paramSet = {};\n\n      while (index < length) {\n        token = lookahead();\n        param = parseVariableIdentifier();\n\n        if (strict) {\n          if (isRestrictedWord(token.value)) {\n            stricted = token;\n            message = Messages.StrictParamName;\n          }\n\n          if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n            stricted = token;\n            message = Messages.StrictParamDupe;\n          }\n        } else if (!firstRestricted) {\n          if (isRestrictedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictParamName;\n          } else if (isStrictModeReservedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictReservedWord;\n          } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictParamDupe;\n          }\n        }\n\n        params.push(param);\n        paramSet[param.name] = true;\n\n        if (match(')')) {\n          break;\n        }\n\n        expect(',');\n      }\n    }\n\n    expect(')');\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n\n    if (strict && firstRestricted) {\n      throwError(firstRestricted, message);\n    }\n\n    if (strict && stricted) {\n      throwErrorTolerant(stricted, message);\n    }\n\n    strict = previousStrict;\n    return {\n      type: Syntax.FunctionDeclaration,\n      id: id,\n      params: params,\n      defaults: [],\n      body: body,\n      rest: null,\n      generator: false,\n      expression: false\n    };\n  }\n\n  function parseFunctionExpression() {\n    var token,\n        id = null,\n        stricted,\n        firstRestricted,\n        message,\n        param,\n        params = [],\n        body,\n        previousStrict,\n        paramSet;\n    expectKeyword('function');\n\n    if (!match('(')) {\n      token = lookahead();\n      id = parseVariableIdentifier();\n\n      if (strict) {\n        if (isRestrictedWord(token.value)) {\n          throwErrorTolerant(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n\n    expect('(');\n\n    if (!match(')')) {\n      paramSet = {};\n\n      while (index < length) {\n        token = lookahead();\n        param = parseVariableIdentifier();\n\n        if (strict) {\n          if (isRestrictedWord(token.value)) {\n            stricted = token;\n            message = Messages.StrictParamName;\n          }\n\n          if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n            stricted = token;\n            message = Messages.StrictParamDupe;\n          }\n        } else if (!firstRestricted) {\n          if (isRestrictedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictParamName;\n          } else if (isStrictModeReservedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictReservedWord;\n          } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictParamDupe;\n          }\n        }\n\n        params.push(param);\n        paramSet[param.name] = true;\n\n        if (match(')')) {\n          break;\n        }\n\n        expect(',');\n      }\n    }\n\n    expect(')');\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n\n    if (strict && firstRestricted) {\n      throwError(firstRestricted, message);\n    }\n\n    if (strict && stricted) {\n      throwErrorTolerant(stricted, message);\n    }\n\n    strict = previousStrict;\n    return {\n      type: Syntax.FunctionExpression,\n      id: id,\n      params: params,\n      defaults: [],\n      body: body,\n      rest: null,\n      generator: false,\n      expression: false\n    };\n  } // 14 Program\n\n\n  function parseSourceElement() {\n    var token = lookahead();\n\n    if (token.type === Token.Keyword) {\n      switch (token.value) {\n        case 'const':\n        case 'let':\n          return parseConstLetDeclaration(token.value);\n\n        case 'function':\n          return parseFunctionDeclaration();\n\n        default:\n          return parseStatement();\n      }\n    }\n\n    if (token.type !== Token.EOF) {\n      return parseStatement();\n    }\n  }\n\n  function parseSourceElements() {\n    var sourceElement,\n        sourceElements = [],\n        token,\n        directive,\n        firstRestricted;\n\n    while (index < length) {\n      token = lookahead();\n\n      if (token.type !== Token.StringLiteral) {\n        break;\n      }\n\n      sourceElement = parseSourceElement();\n      sourceElements.push(sourceElement);\n\n      if (sourceElement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n\n      directive = sliceSource(token.range[0] + 1, token.range[1] - 1);\n\n      if (directive === 'use strict') {\n        strict = true;\n\n        if (firstRestricted) {\n          throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n\n    while (index < length) {\n      sourceElement = parseSourceElement();\n\n      if (typeof sourceElement === 'undefined') {\n        break;\n      }\n\n      sourceElements.push(sourceElement);\n    }\n\n    return sourceElements;\n  }\n\n  function parseProgram() {\n    var program;\n    strict = false;\n    program = {\n      type: Syntax.Program,\n      body: parseSourceElements()\n    };\n    return program;\n  } // The following functions are needed only when the option to preserve\n  // the comments is active.\n\n\n  function addComment(type, value, start, end, loc) {\n    assert(typeof start === 'number', 'Comment must have valid position'); // Because the way the actual token is scanned, often the comments\n    // (if any) are skipped twice during the lexical analysis.\n    // Thus, we need to skip adding a comment if the comment array already\n    // handled it.\n\n    if (extra.comments.length > 0) {\n      if (extra.comments[extra.comments.length - 1].range[1] > start) {\n        return;\n      }\n    }\n\n    extra.comments.push({\n      type: type,\n      value: value,\n      range: [start, end],\n      loc: loc\n    });\n  }\n\n  function scanComment() {\n    var comment, ch, loc, start, blockComment, lineComment;\n    comment = '';\n    blockComment = false;\n    lineComment = false;\n\n    while (index < length) {\n      ch = source[index];\n\n      if (lineComment) {\n        ch = source[index++];\n\n        if (isLineTerminator(ch)) {\n          loc.end = {\n            line: lineNumber,\n            column: index - lineStart - 1\n          };\n          lineComment = false;\n          addComment('Line', comment, start, index - 1, loc);\n\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n\n          ++lineNumber;\n          lineStart = index;\n          comment = '';\n        } else if (index >= length) {\n          lineComment = false;\n          comment += ch;\n          loc.end = {\n            line: lineNumber,\n            column: length - lineStart\n          };\n          addComment('Line', comment, start, length, loc);\n        } else {\n          comment += ch;\n        }\n      } else if (blockComment) {\n        if (isLineTerminator(ch)) {\n          if (ch === '\\r' && source[index + 1] === '\\n') {\n            ++index;\n            comment += '\\r\\n';\n          } else {\n            comment += ch;\n          }\n\n          ++lineNumber;\n          ++index;\n          lineStart = index;\n\n          if (index >= length) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n        } else {\n          ch = source[index++];\n\n          if (index >= length) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n\n          comment += ch;\n\n          if (ch === '*') {\n            ch = source[index];\n\n            if (ch === '/') {\n              comment = comment.substr(0, comment.length - 1);\n              blockComment = false;\n              ++index;\n              loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n              };\n              addComment('Block', comment, start, index, loc);\n              comment = '';\n            }\n          }\n        }\n      } else if (ch === '/') {\n        ch = source[index + 1];\n\n        if (ch === '/') {\n          loc = {\n            start: {\n              line: lineNumber,\n              column: index - lineStart\n            }\n          };\n          start = index;\n          index += 2;\n          lineComment = true;\n\n          if (index >= length) {\n            loc.end = {\n              line: lineNumber,\n              column: index - lineStart\n            };\n            lineComment = false;\n            addComment('Line', comment, start, index, loc);\n          }\n        } else if (ch === '*') {\n          start = index;\n          index += 2;\n          blockComment = true;\n          loc = {\n            start: {\n              line: lineNumber,\n              column: index - lineStart - 2\n            }\n          };\n\n          if (index >= length) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n        } else {\n          break;\n        }\n      } else if (isWhiteSpace(ch)) {\n        ++index;\n      } else if (isLineTerminator(ch)) {\n        ++index;\n\n        if (ch === '\\r' && source[index] === '\\n') {\n          ++index;\n        }\n\n        ++lineNumber;\n        lineStart = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n  function filterCommentLocation() {\n    var i,\n        entry,\n        comment,\n        comments = [];\n\n    for (i = 0; i < extra.comments.length; ++i) {\n      entry = extra.comments[i];\n      comment = {\n        type: entry.type,\n        value: entry.value\n      };\n\n      if (extra.range) {\n        comment.range = entry.range;\n      }\n\n      if (extra.loc) {\n        comment.loc = entry.loc;\n      }\n\n      comments.push(comment);\n    }\n\n    extra.comments = comments;\n  }\n\n  function collectToken() {\n    var start, loc, token, range, value;\n    skipComment();\n    start = index;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    token = extra.advance();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n\n    if (token.type !== Token.EOF) {\n      range = [token.range[0], token.range[1]];\n      value = sliceSource(token.range[0], token.range[1]);\n      extra.tokens.push({\n        type: TokenName[token.type],\n        value: value,\n        range: range,\n        loc: loc\n      });\n    }\n\n    return token;\n  }\n\n  function collectRegex() {\n    var pos, loc, regex, token;\n    skipComment();\n    pos = index;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    regex = extra.scanRegExp();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    }; // Pop the previous token, which is likely '/' or '/='\n\n    if (extra.tokens.length > 0) {\n      token = extra.tokens[extra.tokens.length - 1];\n\n      if (token.range[0] === pos && token.type === 'Punctuator') {\n        if (token.value === '/' || token.value === '/=') {\n          extra.tokens.pop();\n        }\n      }\n    }\n\n    extra.tokens.push({\n      type: 'RegularExpression',\n      value: regex.literal,\n      range: [pos, index],\n      loc: loc\n    });\n    return regex;\n  }\n\n  function filterTokenLocation() {\n    var i,\n        entry,\n        token,\n        tokens = [];\n\n    for (i = 0; i < extra.tokens.length; ++i) {\n      entry = extra.tokens[i];\n      token = {\n        type: entry.type,\n        value: entry.value\n      };\n\n      if (extra.range) {\n        token.range = entry.range;\n      }\n\n      if (extra.loc) {\n        token.loc = entry.loc;\n      }\n\n      tokens.push(token);\n    }\n\n    extra.tokens = tokens;\n  }\n\n  function createLiteral(token) {\n    return {\n      type: Syntax.Literal,\n      value: token.value\n    };\n  }\n\n  function createRawLiteral(token) {\n    return {\n      type: Syntax.Literal,\n      value: token.value,\n      raw: sliceSource(token.range[0], token.range[1])\n    };\n  }\n\n  function createLocationMarker() {\n    var marker = {};\n    marker.range = [index, index];\n    marker.loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      },\n      end: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n\n    marker.end = function () {\n      this.range[1] = index;\n      this.loc.end.line = lineNumber;\n      this.loc.end.column = index - lineStart;\n    };\n\n    marker.applyGroup = function (node) {\n      if (extra.range) {\n        node.groupRange = [this.range[0], this.range[1]];\n      }\n\n      if (extra.loc) {\n        node.groupLoc = {\n          start: {\n            line: this.loc.start.line,\n            column: this.loc.start.column\n          },\n          end: {\n            line: this.loc.end.line,\n            column: this.loc.end.column\n          }\n        };\n      }\n    };\n\n    marker.apply = function (node) {\n      if (extra.range) {\n        node.range = [this.range[0], this.range[1]];\n      }\n\n      if (extra.loc) {\n        node.loc = {\n          start: {\n            line: this.loc.start.line,\n            column: this.loc.start.column\n          },\n          end: {\n            line: this.loc.end.line,\n            column: this.loc.end.column\n          }\n        };\n      }\n    };\n\n    return marker;\n  }\n\n  function trackGroupExpression() {\n    var marker, expr;\n    skipComment();\n    marker = createLocationMarker();\n    expect('(');\n    expr = parseExpression();\n    expect(')');\n    marker.end();\n    marker.applyGroup(expr);\n    return expr;\n  }\n\n  function trackLeftHandSideExpression() {\n    var marker, expr;\n    skipComment();\n    marker = createLocationMarker();\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n    while (match('.') || match('[')) {\n      if (match('[')) {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: true,\n          object: expr,\n          property: parseComputedMember()\n        };\n        marker.end();\n        marker.apply(expr);\n      } else {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: false,\n          object: expr,\n          property: parseNonComputedMember()\n        };\n        marker.end();\n        marker.apply(expr);\n      }\n    }\n\n    return expr;\n  }\n\n  function trackLeftHandSideExpressionAllowCall() {\n    var marker, expr;\n    skipComment();\n    marker = createLocationMarker();\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n    while (match('.') || match('[') || match('(')) {\n      if (match('(')) {\n        expr = {\n          type: Syntax.CallExpression,\n          callee: expr,\n          'arguments': parseArguments()\n        };\n        marker.end();\n        marker.apply(expr);\n      } else if (match('[')) {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: true,\n          object: expr,\n          property: parseComputedMember()\n        };\n        marker.end();\n        marker.apply(expr);\n      } else {\n        expr = {\n          type: Syntax.MemberExpression,\n          computed: false,\n          object: expr,\n          property: parseNonComputedMember()\n        };\n        marker.end();\n        marker.apply(expr);\n      }\n    }\n\n    return expr;\n  }\n\n  function filterGroup(node) {\n    var n, i, entry;\n    n = Object.prototype.toString.apply(node) === '[object Array]' ? [] : {};\n\n    for (i in node) {\n      if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {\n        entry = node[i];\n\n        if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {\n          n[i] = entry;\n        } else {\n          n[i] = filterGroup(entry);\n        }\n      }\n    }\n\n    return n;\n  }\n\n  function wrapTrackingFunction(range, loc) {\n    return function (parseFunction) {\n      function isBinary(node) {\n        return node.type === Syntax.LogicalExpression || node.type === Syntax.BinaryExpression;\n      }\n\n      function visit(node) {\n        var start, end;\n\n        if (isBinary(node.left)) {\n          visit(node.left);\n        }\n\n        if (isBinary(node.right)) {\n          visit(node.right);\n        }\n\n        if (range) {\n          if (node.left.groupRange || node.right.groupRange) {\n            start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];\n            end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];\n            node.range = [start, end];\n          } else if (typeof node.range === 'undefined') {\n            start = node.left.range[0];\n            end = node.right.range[1];\n            node.range = [start, end];\n          }\n        }\n\n        if (loc) {\n          if (node.left.groupLoc || node.right.groupLoc) {\n            start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;\n            end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;\n            node.loc = {\n              start: start,\n              end: end\n            };\n          } else if (typeof node.loc === 'undefined') {\n            node.loc = {\n              start: node.left.loc.start,\n              end: node.right.loc.end\n            };\n          }\n        }\n      }\n\n      return function () {\n        var marker, node;\n        skipComment();\n        marker = createLocationMarker();\n        node = parseFunction.apply(null, arguments);\n        marker.end();\n\n        if (range && typeof node.range === 'undefined') {\n          marker.apply(node);\n        }\n\n        if (loc && typeof node.loc === 'undefined') {\n          marker.apply(node);\n        }\n\n        if (isBinary(node)) {\n          visit(node);\n        }\n\n        return node;\n      };\n    };\n  }\n\n  function patch() {\n    var wrapTracking;\n\n    if (extra.comments) {\n      extra.skipComment = skipComment;\n      skipComment = scanComment;\n    }\n\n    if (extra.raw) {\n      extra.createLiteral = createLiteral;\n      createLiteral = createRawLiteral;\n    }\n\n    if (extra.range || extra.loc) {\n      extra.parseGroupExpression = parseGroupExpression;\n      extra.parseLeftHandSideExpression = parseLeftHandSideExpression;\n      extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;\n      parseGroupExpression = trackGroupExpression;\n      parseLeftHandSideExpression = trackLeftHandSideExpression;\n      parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;\n      wrapTracking = wrapTrackingFunction(extra.range, extra.loc);\n      extra.parseAdditiveExpression = parseAdditiveExpression;\n      extra.parseAssignmentExpression = parseAssignmentExpression;\n      extra.parseBitwiseANDExpression = parseBitwiseANDExpression;\n      extra.parseBitwiseORExpression = parseBitwiseORExpression;\n      extra.parseBitwiseXORExpression = parseBitwiseXORExpression;\n      extra.parseBlock = parseBlock;\n      extra.parseFunctionSourceElements = parseFunctionSourceElements;\n      extra.parseCatchClause = parseCatchClause;\n      extra.parseComputedMember = parseComputedMember;\n      extra.parseConditionalExpression = parseConditionalExpression;\n      extra.parseConstLetDeclaration = parseConstLetDeclaration;\n      extra.parseEqualityExpression = parseEqualityExpression;\n      extra.parseExpression = parseExpression;\n      extra.parseForVariableDeclaration = parseForVariableDeclaration;\n      extra.parseFunctionDeclaration = parseFunctionDeclaration;\n      extra.parseFunctionExpression = parseFunctionExpression;\n      extra.parseLogicalANDExpression = parseLogicalANDExpression;\n      extra.parseLogicalORExpression = parseLogicalORExpression;\n      extra.parseMultiplicativeExpression = parseMultiplicativeExpression;\n      extra.parseNewExpression = parseNewExpression;\n      extra.parseNonComputedProperty = parseNonComputedProperty;\n      extra.parseObjectProperty = parseObjectProperty;\n      extra.parseObjectPropertyKey = parseObjectPropertyKey;\n      extra.parsePostfixExpression = parsePostfixExpression;\n      extra.parsePrimaryExpression = parsePrimaryExpression;\n      extra.parseProgram = parseProgram;\n      extra.parsePropertyFunction = parsePropertyFunction;\n      extra.parseRelationalExpression = parseRelationalExpression;\n      extra.parseStatement = parseStatement;\n      extra.parseShiftExpression = parseShiftExpression;\n      extra.parseSwitchCase = parseSwitchCase;\n      extra.parseUnaryExpression = parseUnaryExpression;\n      extra.parseVariableDeclaration = parseVariableDeclaration;\n      extra.parseVariableIdentifier = parseVariableIdentifier;\n      parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);\n      parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);\n      parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);\n      parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);\n      parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);\n      parseBlock = wrapTracking(extra.parseBlock);\n      parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);\n      parseCatchClause = wrapTracking(extra.parseCatchClause);\n      parseComputedMember = wrapTracking(extra.parseComputedMember);\n      parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);\n      parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);\n      parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);\n      parseExpression = wrapTracking(extra.parseExpression);\n      parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);\n      parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);\n      parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);\n      parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);\n      parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);\n      parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);\n      parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);\n      parseNewExpression = wrapTracking(extra.parseNewExpression);\n      parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);\n      parseObjectProperty = wrapTracking(extra.parseObjectProperty);\n      parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);\n      parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);\n      parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);\n      parseProgram = wrapTracking(extra.parseProgram);\n      parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);\n      parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);\n      parseStatement = wrapTracking(extra.parseStatement);\n      parseShiftExpression = wrapTracking(extra.parseShiftExpression);\n      parseSwitchCase = wrapTracking(extra.parseSwitchCase);\n      parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);\n      parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);\n      parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);\n    }\n\n    if (typeof extra.tokens !== 'undefined') {\n      extra.advance = advance;\n      extra.scanRegExp = scanRegExp;\n      advance = collectToken;\n      scanRegExp = collectRegex;\n    }\n  }\n\n  function unpatch() {\n    if (typeof extra.skipComment === 'function') {\n      skipComment = extra.skipComment;\n    }\n\n    if (extra.raw) {\n      createLiteral = extra.createLiteral;\n    }\n\n    if (extra.range || extra.loc) {\n      parseAdditiveExpression = extra.parseAdditiveExpression;\n      parseAssignmentExpression = extra.parseAssignmentExpression;\n      parseBitwiseANDExpression = extra.parseBitwiseANDExpression;\n      parseBitwiseORExpression = extra.parseBitwiseORExpression;\n      parseBitwiseXORExpression = extra.parseBitwiseXORExpression;\n      parseBlock = extra.parseBlock;\n      parseFunctionSourceElements = extra.parseFunctionSourceElements;\n      parseCatchClause = extra.parseCatchClause;\n      parseComputedMember = extra.parseComputedMember;\n      parseConditionalExpression = extra.parseConditionalExpression;\n      parseConstLetDeclaration = extra.parseConstLetDeclaration;\n      parseEqualityExpression = extra.parseEqualityExpression;\n      parseExpression = extra.parseExpression;\n      parseForVariableDeclaration = extra.parseForVariableDeclaration;\n      parseFunctionDeclaration = extra.parseFunctionDeclaration;\n      parseFunctionExpression = extra.parseFunctionExpression;\n      parseGroupExpression = extra.parseGroupExpression;\n      parseLeftHandSideExpression = extra.parseLeftHandSideExpression;\n      parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;\n      parseLogicalANDExpression = extra.parseLogicalANDExpression;\n      parseLogicalORExpression = extra.parseLogicalORExpression;\n      parseMultiplicativeExpression = extra.parseMultiplicativeExpression;\n      parseNewExpression = extra.parseNewExpression;\n      parseNonComputedProperty = extra.parseNonComputedProperty;\n      parseObjectProperty = extra.parseObjectProperty;\n      parseObjectPropertyKey = extra.parseObjectPropertyKey;\n      parsePrimaryExpression = extra.parsePrimaryExpression;\n      parsePostfixExpression = extra.parsePostfixExpression;\n      parseProgram = extra.parseProgram;\n      parsePropertyFunction = extra.parsePropertyFunction;\n      parseRelationalExpression = extra.parseRelationalExpression;\n      parseStatement = extra.parseStatement;\n      parseShiftExpression = extra.parseShiftExpression;\n      parseSwitchCase = extra.parseSwitchCase;\n      parseUnaryExpression = extra.parseUnaryExpression;\n      parseVariableDeclaration = extra.parseVariableDeclaration;\n      parseVariableIdentifier = extra.parseVariableIdentifier;\n    }\n\n    if (typeof extra.scanRegExp === 'function') {\n      advance = extra.advance;\n      scanRegExp = extra.scanRegExp;\n    }\n  }\n\n  function stringToArray(str) {\n    var length = str.length,\n        result = [],\n        i;\n\n    for (i = 0; i < length; ++i) {\n      result[i] = str.charAt(i);\n    }\n\n    return result;\n  }\n\n  function parse(code, options) {\n    var program, toString;\n    toString = String;\n\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    length = source.length;\n    buffer = null;\n    state = {\n      allowIn: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false\n    };\n    extra = {};\n\n    if (typeof options !== 'undefined') {\n      extra.range = typeof options.range === 'boolean' && options.range;\n      extra.loc = typeof options.loc === 'boolean' && options.loc;\n      extra.raw = typeof options.raw === 'boolean' && options.raw;\n\n      if (typeof options.tokens === 'boolean' && options.tokens) {\n        extra.tokens = [];\n      }\n\n      if (typeof options.comment === 'boolean' && options.comment) {\n        extra.comments = [];\n      }\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n        extra.errors = [];\n      }\n    }\n\n    if (length > 0) {\n      if (typeof source[0] === 'undefined') {\n        // Try first to convert to a string. This is good as fast path\n        // for old IE which understands string indexing for string\n        // literals only and not for string object.\n        if (code instanceof String) {\n          source = code.valueOf();\n        } // Force accessing the characters via an array.\n\n\n        if (typeof source[0] === 'undefined') {\n          source = stringToArray(code);\n        }\n      }\n    }\n\n    patch();\n\n    try {\n      program = parseProgram();\n\n      if (typeof extra.comments !== 'undefined') {\n        filterCommentLocation();\n        program.comments = extra.comments;\n      }\n\n      if (typeof extra.tokens !== 'undefined') {\n        filterTokenLocation();\n        program.tokens = extra.tokens;\n      }\n\n      if (typeof extra.errors !== 'undefined') {\n        program.errors = extra.errors;\n      }\n\n      if (extra.range || extra.loc) {\n        program.body = filterGroup(program.body);\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      unpatch();\n      extra = {};\n    }\n\n    return program;\n  } // Sync with package.json.\n\n\n  exports.version = '1.0.4';\n  exports.parse = parse; // Deep copy.\n\n  exports.Syntax = function () {\n    var name,\n        types = {};\n\n    if (typeof Object.create === 'function') {\n      types = Object.create(null);\n    }\n\n    for (name in Syntax) {\n      if (Syntax.hasOwnProperty(name)) {\n        types[name] = Syntax[name];\n      }\n    }\n\n    if (typeof Object.freeze === 'function') {\n      Object.freeze(types);\n    }\n\n    return types;\n  }();\n});\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"names":["root","factory","define","amd","exports","esprima","Token","TokenName","Syntax","PropertyKind","Messages","Regex","source","strict","index","lineNumber","lineStart","length","buffer","state","extra","BooleanLiteral","EOF","Identifier","Keyword","NullLiteral","NumericLiteral","Punctuator","StringLiteral","AssignmentExpression","ArrayExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ConditionalExpression","ContinueStatement","DoWhileStatement","DebuggerStatement","EmptyStatement","ExpressionStatement","ForStatement","ForInStatement","FunctionDeclaration","FunctionExpression","IfStatement","Literal","LabeledStatement","LogicalExpression","MemberExpression","NewExpression","ObjectExpression","Program","Property","ReturnStatement","SequenceExpression","SwitchStatement","SwitchCase","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","Data","Get","Set","UnexpectedToken","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","UnexpectedEOS","NewlineAfterThrow","InvalidRegExp","UnterminatedRegExp","InvalidLHSInAssignment","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictOctalLiteral","StrictDelete","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","StrictReservedWord","NonAsciiIdentifierStart","RegExp","NonAsciiIdentifierPart","assert","condition","message","Error","sliceSource","from","to","slice","sliceArraySource","join","isDecimalDigit","ch","indexOf","isHexDigit","isOctalDigit","isWhiteSpace","charCodeAt","isLineTerminator","isIdentifierStart","test","isIdentifierPart","isFutureReservedWord","id","isStrictModeReservedWord","isRestrictedWord","isKeyword","keyword","skipComment","blockComment","lineComment","throwError","scanHexEscape","prefix","i","len","code","toLowerCase","String","fromCharCode","scanIdentifier","start","restore","type","value","range","scanPunctuator","ch1","ch2","ch3","ch4","scanNumericLiteral","number","parseInt","octal","parseFloat","scanStringLiteral","str","quote","unescaped","scanRegExp","pattern","flags","classMarker","terminated","substr","e","literal","isIdentifierName","token","advance","lex","lookahead","pos","line","peekLineTerminator","found","messageFormat","error","args","Array","prototype","call","arguments","msg","replace","whole","column","throwErrorTolerant","apply","errors","push","throwUnexpected","expect","expectKeyword","match","matchKeyword","matchAssign","op","consumeSemicolon","isLeftHandSide","expr","parseArrayInitialiser","elements","parseAssignmentExpression","parsePropertyFunction","param","first","previousStrict","body","parseFunctionSourceElements","name","params","defaults","rest","generator","expression","parseObjectPropertyKey","createLiteral","parseObjectProperty","key","kind","parseVariableIdentifier","parseObjectInitialiser","properties","property","map","toString","Object","hasOwnProperty","parseGroupExpression","parseExpression","parsePrimaryExpression","parseFunctionExpression","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseNewExpression","callee","parseLeftHandSideExpression","parseLeftHandSideExpressionAllowCall","computed","object","parsePostfixExpression","operator","argument","parseUnaryExpression","parseMultiplicativeExpression","left","right","parseAdditiveExpression","parseShiftExpression","parseRelationalExpression","previousAllowIn","allowIn","parseEqualityExpression","parseBitwiseANDExpression","parseBitwiseXORExpression","parseBitwiseORExpression","parseLogicalANDExpression","parseLogicalORExpression","parseConditionalExpression","consequent","alternate","expressions","parseStatementList","list","statement","parseSourceElement","parseBlock","block","parseVariableDeclaration","init","parseVariableDeclarationList","parseVariableStatement","declarations","parseConstLetDeclaration","parseEmptyStatement","parseExpressionStatement","parseIfStatement","parseStatement","parseDoWhileStatement","oldInIteration","inIteration","parseWhileStatement","parseForVariableDeclaration","parseForStatement","update","each","parseContinueStatement","label","labelSet","parseBreakStatement","inSwitch","parseReturnStatement","inFunctionBody","parseWithStatement","parseSwitchCase","parseSwitchStatement","discriminant","cases","clause","oldInSwitch","defaultFound","parseThrowStatement","parseCatchClause","parseTryStatement","handlers","finalizer","guardedHandlers","parseDebuggerStatement","labeledBody","parseFunctionDeclaration","sourceElement","sourceElements","directive","firstRestricted","oldLabelSet","oldInFunctionBody","stricted","paramSet","parseSourceElements","parseProgram","program","addComment","end","loc","comments","scanComment","comment","filterCommentLocation","entry","collectToken","tokens","collectRegex","regex","pop","filterTokenLocation","createRawLiteral","raw","createLocationMarker","marker","applyGroup","node","groupRange","groupLoc","trackGroupExpression","trackLeftHandSideExpression","trackLeftHandSideExpressionAllowCall","filterGroup","n","wrapTrackingFunction","parseFunction","isBinary","visit","patch","wrapTracking","unpatch","stringToArray","result","charAt","parse","options","tolerant","valueOf","version","types","create","freeze"],"sources":["/home/emilio/Área de Trabalho/OneBitCode-aulas/REACT/site-react-login-live/react-controlledForms/node_modules/redeyed/node_modules/esprima/esprima.js"],"sourcesContent":["/*\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n/*global esprima:true, define:true, exports:true, window: true,\nthrowError: true, createLiteral: true, generateStatement: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseStatement: true, parseSourceElement: true */\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        buffer,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken:  'Unexpected token %0',\n        UnexpectedNumber:  'Unexpected number',\n        UnexpectedString:  'Unexpected string',\n        UnexpectedIdentifier:  'Unexpected identifier',\n        UnexpectedReserved:  'Unexpected reserved word',\n        UnexpectedEOS:  'Unexpected end of input',\n        NewlineAfterThrow:  'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp:  'Invalid regular expression: missing /',\n        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n        InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally:  'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith:  'Strict mode code may not include a with statement',\n        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n        StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord:  'Use of future reserved word in strict mode'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function sliceSource(from, to) {\n        return source.slice(from, to);\n    }\n\n    if (typeof 'esprima'[0] === 'undefined') {\n        sliceSource = function sliceArraySource(from, to) {\n            return source.slice(from, to).join('');\n        };\n    }\n\n    function isDecimalDigit(ch) {\n        return '0123456789'.indexOf(ch) >= 0;\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === ' ') || (ch === '\\u0009') || (ch === '\\u000B') ||\n            (ch === '\\u000C') || (ch === '\\u00A0') ||\n            (ch.charCodeAt(0) >= 0x1680 &&\n             '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === '\\n' || ch === '\\r' || ch === '\\u2028' || ch === '\\u2029');\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === '$') || (ch === '_') || (ch === '\\\\') ||\n            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierStart.test(ch));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === '$') || (ch === '_') || (ch === '\\\\') ||\n            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n            ((ch >= '0') && (ch <= '9')) ||\n            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierPart.test(ch));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n\n        // Future reserved words.\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        }\n\n        return false;\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n\n        // Strict Mode reserved words.\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        }\n\n        return false;\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        var keyword = false;\n        switch (id.length) {\n        case 2:\n            keyword = (id === 'if') || (id === 'in') || (id === 'do');\n            break;\n        case 3:\n            keyword = (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');\n            break;\n        case 4:\n            keyword = (id === 'this') || (id === 'else') || (id === 'case') || (id === 'void') || (id === 'with');\n            break;\n        case 5:\n            keyword = (id === 'while') || (id === 'break') || (id === 'catch') || (id === 'throw');\n            break;\n        case 6:\n            keyword = (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch');\n            break;\n        case 7:\n            keyword = (id === 'default') || (id === 'finally');\n            break;\n        case 8:\n            keyword = (id === 'function') || (id === 'continue') || (id === 'debugger');\n            break;\n        case 10:\n            keyword = (id === 'instanceof');\n            break;\n        }\n\n        if (keyword) {\n            return true;\n        }\n\n        switch (id) {\n        // Future reserved words.\n        // 'const' is specialized as Keyword in V8.\n        case 'const':\n            return true;\n\n        // For compatiblity to SpiderMonkey and ES.next\n        case 'yield':\n        case 'let':\n            return true;\n        }\n\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        return isFutureReservedWord(id);\n    }\n\n    // 7.4 Comments\n\n    function skipComment() {\n        var ch, blockComment, lineComment;\n\n        blockComment = false;\n        lineComment = false;\n\n        while (index < length) {\n            ch = source[index];\n\n            if (lineComment) {\n                ch = source[index++];\n                if (isLineTerminator(ch)) {\n                    lineComment = false;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch)) {\n                    if (ch === '\\r' && source[index + 1] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    ++index;\n                    lineStart = index;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    ch = source[index++];\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    if (ch === '*') {\n                        ch = source[index];\n                        if (ch === '/') {\n                            ++index;\n                            blockComment = false;\n                        }\n                    }\n                }\n            } else if (ch === '/') {\n                ch = source[index + 1];\n                if (ch === '/') {\n                    index += 2;\n                    lineComment = true;\n                } else if (ch === '*') {\n                    index += 2;\n                    blockComment = true;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch ===  '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanIdentifier() {\n        var ch, start, id, restore;\n\n        ch = source[index];\n        if (!isIdentifierStart(ch)) {\n            return;\n        }\n\n        start = index;\n        if (ch === '\\\\') {\n            ++index;\n            if (source[index] !== 'u') {\n                return;\n            }\n            ++index;\n            restore = index;\n            ch = scanHexEscape('u');\n            if (ch) {\n                if (ch === '\\\\' || !isIdentifierStart(ch)) {\n                    return;\n                }\n                id = ch;\n            } else {\n                index = restore;\n                id = 'u';\n            }\n        } else {\n            id = source[index++];\n        }\n\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            if (ch === '\\\\') {\n                ++index;\n                if (source[index] !== 'u') {\n                    return;\n                }\n                ++index;\n                restore = index;\n                ch = scanHexEscape('u');\n                if (ch) {\n                    if (ch === '\\\\' || !isIdentifierPart(ch)) {\n                        return;\n                    }\n                    id += ch;\n                } else {\n                    index = restore;\n                    id += 'u';\n                }\n            } else {\n                id += source[index++];\n            }\n        }\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            return {\n                type: Token.Identifier,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (isKeyword(id)) {\n            return {\n                type: Token.Keyword,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // 7.8.1 Null Literals\n\n        if (id === 'null') {\n            return {\n                type: Token.NullLiteral,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // 7.8.2 Boolean Literals\n\n        if (id === 'true' || id === 'false') {\n            return {\n                type: Token.BooleanLiteral,\n                value: id,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        return {\n            type: Token.Identifier,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        // Check for most common single-character punctuators.\n\n        if (ch1 === ';' || ch1 === '{' || ch1 === '}') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === ',' || ch1 === '(' || ch1 === ')') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Dot (.) can also start a floating-point number, hence the need\n        // to check the next character.\n\n        ch2 = source[index + 1];\n        if (ch1 === '.' && !isDecimalDigit(ch2)) {\n            return {\n                type: Token.Punctuator,\n                value: source[index++],\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Peek more characters.\n\n        ch3 = source[index + 2];\n        ch4 = source[index + 3];\n\n        // 4-character punctuator: >>>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            if (ch4 === '=') {\n                index += 4;\n                return {\n                    type: Token.Punctuator,\n                    value: '>>>=',\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        if (ch1 === '=' && ch2 === '=' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '===',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '!' && ch2 === '=' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '!==',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '<<=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // 2-character punctuators: <= >= == != ++ -- << >> && ||\n        // += -= *= %= &= |= ^= /=\n\n        if (ch2 === '=') {\n            if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n                index += 2;\n                return {\n                    type: Token.Punctuator,\n                    value: ch1 + ch2,\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {\n            if ('+-<>&|'.indexOf(ch2) >= 0) {\n                index += 2;\n                return {\n                    type: Token.Punctuator,\n                    value: ch1 + ch2,\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // The remaining 1-character punctuators.\n\n        if ('[]<>+-*%&|^!~?:=/'.indexOf(ch1) >= 0) {\n            return {\n                type: Token.Punctuator,\n                value: source[index++],\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    number += source[index++];\n                    while (index < length) {\n                        ch = source[index];\n                        if (!isHexDigit(ch)) {\n                            break;\n                        }\n                        number += source[index++];\n                    }\n\n                    if (number.length <= 2) {\n                        // only 0x\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n\n                    if (index < length) {\n                        ch = source[index];\n                        if (isIdentifierStart(ch)) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                    return {\n                        type: Token.NumericLiteral,\n                        value: parseInt(number, 16),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                } else if (isOctalDigit(ch)) {\n                    number += source[index++];\n                    while (index < length) {\n                        ch = source[index];\n                        if (!isOctalDigit(ch)) {\n                            break;\n                        }\n                        number += source[index++];\n                    }\n\n                    if (index < length) {\n                        ch = source[index];\n                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                    return {\n                        type: Token.NumericLiteral,\n                        value: parseInt(number, 8),\n                        octal: true,\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                }\n\n                // decimal number starts with '0' such as '09' is illegal.\n                if (isDecimalDigit(ch)) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n\n            while (index < length) {\n                ch = source[index];\n                if (!isDecimalDigit(ch)) {\n                    break;\n                }\n                number += source[index++];\n            }\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (index < length) {\n                ch = source[index];\n                if (!isDecimalDigit(ch)) {\n                    break;\n                }\n                number += source[index++];\n            }\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n\n            ch = source[index];\n            if (isDecimalDigit(ch)) {\n                number += source[index++];\n                while (index < length) {\n                    ch = source[index];\n                    if (!isDecimalDigit(ch)) {\n                        break;\n                    }\n                    number += source[index++];\n                }\n            } else {\n                ch = 'character ' + ch;\n                if (index >= length) {\n                    ch = '<end>';\n                }\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (index < length) {\n            ch = source[index];\n            if (isIdentifierStart(ch)) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch)) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                }\n            } else if (isLineTerminator(ch)) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanRegExp() {\n        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;\n\n        buffer = null;\n        skipComment();\n\n        start = index;\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch)) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                } else if (isLineTerminator(ch)) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        pattern = str.substr(1, str.length - 2);\n\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        str += '\\\\u';\n                        for (; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                } else {\n                    str += '\\\\';\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n\n        return {\n            literal: str,\n            value: value,\n            range: [start, index]\n        };\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advance() {\n        var ch, token;\n\n        skipComment();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [index, index]\n            };\n        }\n\n        token = scanPunctuator();\n        if (typeof token !== 'undefined') {\n            return token;\n        }\n\n        ch = source[index];\n\n        if (ch === '\\'' || ch === '\"') {\n            return scanStringLiteral();\n        }\n\n        if (ch === '.' || isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        token = scanIdentifier();\n        if (typeof token !== 'undefined') {\n            return token;\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    function lex() {\n        var token;\n\n        if (buffer) {\n            index = buffer.range[1];\n            lineNumber = buffer.lineNumber;\n            lineStart = buffer.lineStart;\n            token = buffer;\n            buffer = null;\n            return token;\n        }\n\n        buffer = null;\n        return advance();\n    }\n\n    function lookahead() {\n        var pos, line, start;\n\n        if (buffer !== null) {\n            return buffer;\n        }\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        buffer = advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return buffer;\n    }\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, index) {\n                    return args[index] || '';\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.range[0];\n            error.lineNumber = token.lineNumber;\n            error.column = token.range[0] - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        var token = lookahead();\n        return token.type === Token.Punctuator && token.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        var token = lookahead();\n        return token.type === Token.Keyword && token.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var token = lookahead(),\n            op = token.value;\n\n        if (token.type !== Token.Punctuator) {\n            return false;\n        }\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        var token, line;\n\n        // Catch the very common case first.\n        if (source[index] === ';') {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            return;\n        }\n\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        token = lookahead();\n        if (token.type !== Token.EOF && !match('}')) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [];\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                elements.push(parseAssignmentExpression());\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        expect(']');\n\n        return {\n            type: Syntax.ArrayExpression,\n            elements: elements\n        };\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(param, first) {\n        var previousStrict, body;\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (first && strict && isRestrictedWord(param[0].name)) {\n            throwErrorTolerant(first, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n\n        return {\n            type: Syntax.FunctionExpression,\n            id: null,\n            params: param,\n            defaults: [],\n            body: body,\n            rest: null,\n            generator: false,\n            expression: false\n        };\n    }\n\n    function parseObjectPropertyKey() {\n        var token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return createLiteral(token);\n        }\n\n        return {\n            type: Syntax.Identifier,\n            name: token.value\n        };\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, param;\n\n        token = lookahead();\n\n        if (token.type === Token.Identifier) {\n\n            id = parseObjectPropertyKey();\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                return {\n                    type: Syntax.Property,\n                    key: key,\n                    value: parsePropertyFunction([]),\n                    kind: 'get'\n                };\n            } else if (token.value === 'set' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead();\n                if (token.type !== Token.Identifier) {\n                    expect(')');\n                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n                    return {\n                        type: Syntax.Property,\n                        key: key,\n                        value: parsePropertyFunction([]),\n                        kind: 'set'\n                    };\n                } else {\n                    param = [ parseVariableIdentifier() ];\n                    expect(')');\n                    return {\n                        type: Syntax.Property,\n                        key: key,\n                        value: parsePropertyFunction(param, token),\n                        kind: 'set'\n                    };\n                }\n            } else {\n                expect(':');\n                return {\n                    type: Syntax.Property,\n                    key: id,\n                    value: parseAssignmentExpression(),\n                    kind: 'init'\n                };\n            }\n        } else if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            throwUnexpected(token);\n        } else {\n            key = parseObjectPropertyKey();\n            expect(':');\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: parseAssignmentExpression(),\n                kind: 'init'\n            };\n        }\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, kind, map = {}, toString = String;\n\n        expect('{');\n\n        while (!match('}')) {\n            property = parseObjectProperty();\n\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n            if (Object.prototype.hasOwnProperty.call(map, name)) {\n                if (map[name] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    } else if (map[name] & kind) {\n                        throwErrorTolerant({}, Messages.AccessorGetSet);\n                    }\n                }\n                map[name] |= kind;\n            } else {\n                map[name] = kind;\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return {\n            type: Syntax.ObjectExpression,\n            properties: properties\n        };\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var token = lookahead(),\n            type = token.type;\n\n        if (type === Token.Identifier) {\n            return {\n                type: Syntax.Identifier,\n                name: lex().value\n            };\n        }\n\n        if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return createLiteral(lex());\n        }\n\n        if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                lex();\n                return {\n                    type: Syntax.ThisExpression\n                };\n            }\n\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n        }\n\n        if (type === Token.BooleanLiteral) {\n            lex();\n            token.value = (token.value === 'true');\n            return createLiteral(token);\n        }\n\n        if (type === Token.NullLiteral) {\n            lex();\n            token.value = null;\n            return createLiteral(token);\n        }\n\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        if (match('/') || match('/=')) {\n            return createLiteral(scanRegExp());\n        }\n\n        return throwUnexpected(lex());\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                args.push(parseAssignmentExpression());\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return {\n            type: Syntax.Identifier,\n            name: token.value\n        };\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var expr;\n\n        expectKeyword('new');\n\n        expr = {\n            type: Syntax.NewExpression,\n            callee: parseLeftHandSideExpression(),\n            'arguments': []\n        };\n\n        if (match('(')) {\n            expr['arguments'] = parseArguments();\n        }\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(')) {\n            if (match('(')) {\n                expr = {\n                    type: Syntax.CallExpression,\n                    callee: expr,\n                    'arguments': parseArguments()\n                };\n            } else if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n            }\n        }\n\n        return expr;\n    }\n\n\n    function parseLeftHandSideExpression() {\n        var expr;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr = parseLeftHandSideExpressionAllowCall(), token;\n\n        token = lookahead();\n        if (token.type !== Token.Punctuator) {\n            return expr;\n        }\n\n        if ((match('++') || match('--')) && !peekLineTerminator()) {\n            // 11.3.1, 11.3.2\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPostfix);\n            }\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = {\n                type: Syntax.UpdateExpression,\n                operator: lex().value,\n                argument: expr,\n                prefix: false\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr;\n\n        token = lookahead();\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return parsePostfixExpression();\n        }\n\n        if (match('++') || match('--')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = {\n                type: Syntax.UpdateExpression,\n                operator: token.value,\n                argument: expr,\n                prefix: true\n            };\n            return expr;\n        }\n\n        if (match('+') || match('-') || match('~') || match('!')) {\n            expr = {\n                type: Syntax.UnaryExpression,\n                operator: lex().value,\n                argument: parseUnaryExpression(),\n                prefix: true\n            };\n            return expr;\n        }\n\n        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            expr = {\n                type: Syntax.UnaryExpression,\n                operator: lex().value,\n                argument: parseUnaryExpression(),\n                prefix: true\n            };\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n            return expr;\n        }\n\n        return parsePostfixExpression();\n    }\n\n    // 11.5 Multiplicative Operators\n\n    function parseMultiplicativeExpression() {\n        var expr = parseUnaryExpression();\n\n        while (match('*') || match('/') || match('%')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseUnaryExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.6 Additive Operators\n\n    function parseAdditiveExpression() {\n        var expr = parseMultiplicativeExpression();\n\n        while (match('+') || match('-')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseMultiplicativeExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.7 Bitwise Shift Operators\n\n    function parseShiftExpression() {\n        var expr = parseAdditiveExpression();\n\n        while (match('<<') || match('>>') || match('>>>')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseAdditiveExpression()\n            };\n        }\n\n        return expr;\n    }\n    // 11.8 Relational Operators\n\n    function parseRelationalExpression() {\n        var expr, previousAllowIn;\n\n        previousAllowIn = state.allowIn;\n        state.allowIn = true;\n\n        expr = parseShiftExpression();\n\n        while (match('<') || match('>') || match('<=') || match('>=') || (previousAllowIn && matchKeyword('in')) || matchKeyword('instanceof')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseShiftExpression()\n            };\n        }\n\n        state.allowIn = previousAllowIn;\n        return expr;\n    }\n\n    // 11.9 Equality Operators\n\n    function parseEqualityExpression() {\n        var expr = parseRelationalExpression();\n\n        while (match('==') || match('!=') || match('===') || match('!==')) {\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseRelationalExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.10 Binary Bitwise Operators\n\n    function parseBitwiseANDExpression() {\n        var expr = parseEqualityExpression();\n\n        while (match('&')) {\n            lex();\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: '&',\n                left: expr,\n                right: parseEqualityExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    function parseBitwiseXORExpression() {\n        var expr = parseBitwiseANDExpression();\n\n        while (match('^')) {\n            lex();\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: '^',\n                left: expr,\n                right: parseBitwiseANDExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    function parseBitwiseORExpression() {\n        var expr = parseBitwiseXORExpression();\n\n        while (match('|')) {\n            lex();\n            expr = {\n                type: Syntax.BinaryExpression,\n                operator: '|',\n                left: expr,\n                right: parseBitwiseXORExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.11 Binary Logical Operators\n\n    function parseLogicalANDExpression() {\n        var expr = parseBitwiseORExpression();\n\n        while (match('&&')) {\n            lex();\n            expr = {\n                type: Syntax.LogicalExpression,\n                operator: '&&',\n                left: expr,\n                right: parseBitwiseORExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    function parseLogicalORExpression() {\n        var expr = parseLogicalANDExpression();\n\n        while (match('||')) {\n            lex();\n            expr = {\n                type: Syntax.LogicalExpression,\n                operator: '||',\n                left: expr,\n                right: parseLogicalANDExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent;\n\n        expr = parseLogicalORExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n\n            expr = {\n                type: Syntax.ConditionalExpression,\n                test: expr,\n                consequent: consequent,\n                alternate: parseAssignmentExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, expr;\n\n        token = lookahead();\n        expr = parseConditionalExpression();\n\n        if (matchAssign()) {\n            // LeftHandSideExpression\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            expr = {\n                type: Syntax.AssignmentExpression,\n                operator: lex().value,\n                left: expr,\n                right: parseAssignmentExpression()\n            };\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr = parseAssignmentExpression();\n\n        if (match(',')) {\n            expr = {\n                type: Syntax.SequenceExpression,\n                expressions: [ expr ]\n            };\n\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expr.expressions.push(parseAssignmentExpression());\n            }\n\n        }\n        return expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block;\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return {\n            type: Syntax.BlockStatement,\n            body: block\n        };\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token = lex();\n\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n\n        return {\n            type: Syntax.Identifier,\n            name: token.value\n        };\n    }\n\n    function parseVariableDeclaration(kind) {\n        var id = parseVariableIdentifier(),\n            init = null;\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            throwErrorTolerant({}, Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return {\n            type: Syntax.VariableDeclarator,\n            id: id,\n            init: init\n        };\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement() {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.VariableDeclaration,\n            declarations: declarations,\n            kind: 'var'\n        };\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations;\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.VariableDeclaration,\n            declarations: declarations,\n            kind: kind\n        };\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        expect(';');\n\n        return {\n            type: Syntax.EmptyStatement\n        };\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var expr = parseExpression();\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ExpressionStatement,\n            expression: expr\n        };\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement() {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return {\n            type: Syntax.IfStatement,\n            test: test,\n            consequent: consequent,\n            alternate: alternate\n        };\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return {\n            type: Syntax.DoWhileStatement,\n            body: body,\n            test: test\n        };\n    }\n\n    function parseWhileStatement() {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return {\n            type: Syntax.WhileStatement,\n            test: test,\n            body: body\n        };\n    }\n\n    function parseForVariableDeclaration() {\n        var token = lex();\n\n        return {\n            type: Syntax.VariableDeclaration,\n            declarations: parseVariableDeclarationList(),\n            kind: token.value\n        };\n    }\n\n    function parseForStatement() {\n        var init, test, update, left, right, body, oldInIteration;\n\n        init = test = update = null;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = true;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = true;\n\n                if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isLeftHandSide(init)) {\n                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        if (typeof left === 'undefined') {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        }\n\n        return {\n            type: Syntax.ForInStatement,\n            left: left,\n            right: right,\n            body: body,\n            each: false\n        };\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement() {\n        var token, label = null;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source[index] === ';') {\n            lex();\n\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return {\n                type: Syntax.ContinueStatement,\n                label: null\n            };\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return {\n                type: Syntax.ContinueStatement,\n                label: null\n            };\n        }\n\n        token = lookahead();\n        if (token.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n\n        return {\n            type: Syntax.ContinueStatement,\n            label: label\n        };\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement() {\n        var token, label = null;\n\n        expectKeyword('break');\n\n        // Optimize the most common form: 'break;'.\n        if (source[index] === ';') {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return {\n                type: Syntax.BreakStatement,\n                label: null\n            };\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return {\n                type: Syntax.BreakStatement,\n                label: null\n            };\n        }\n\n        token = lookahead();\n        if (token.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n\n        return {\n            type: Syntax.BreakStatement,\n            label: label\n        };\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement() {\n        var token, argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source[index] === ' ') {\n            if (isIdentifierStart(source[index + 1])) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return {\n                    type: Syntax.ReturnStatement,\n                    argument: argument\n                };\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: null\n            };\n        }\n\n        if (!match(';')) {\n            token = lookahead();\n            if (!match('}') && token.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ReturnStatement,\n            argument: argument\n        };\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement() {\n        var object, body;\n\n        if (strict) {\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return {\n            type: Syntax.WithStatement,\n            object: object,\n            body: body\n        };\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test,\n            consequent = [],\n            statement;\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            consequent.push(statement);\n        }\n\n        return {\n            type: Syntax.SwitchCase,\n            test: test,\n            consequent: consequent\n        };\n    }\n\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return {\n            type: Syntax.SwitchStatement,\n            discriminant: discriminant,\n            cases: cases\n        };\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement() {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ThrowStatement,\n            argument: argument\n        };\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param;\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead());\n        }\n\n        param = parseVariableIdentifier();\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n\n        return {\n            type: Syntax.CatchClause,\n            param: param,\n            body: parseBlock()\n        };\n    }\n\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n\n        return {\n            type: Syntax.TryStatement,\n            block: block,\n            guardedHandlers: [],\n            handlers: handlers,\n            finalizer: finalizer\n        };\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement() {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.DebuggerStatement\n        };\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var token = lookahead(),\n            expr,\n            labeledBody;\n\n        if (token.type === Token.EOF) {\n            throwUnexpected(token);\n        }\n\n        if (token.type === Token.Punctuator) {\n            switch (token.value) {\n            case ';':\n                return parseEmptyStatement();\n            case '{':\n                return parseBlock();\n            case '(':\n                return parseExpressionStatement();\n            default:\n                break;\n            }\n        }\n\n        if (token.type === Token.Keyword) {\n            switch (token.value) {\n            case 'break':\n                return parseBreakStatement();\n            case 'continue':\n                return parseContinueStatement();\n            case 'debugger':\n                return parseDebuggerStatement();\n            case 'do':\n                return parseDoWhileStatement();\n            case 'for':\n                return parseForStatement();\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'if':\n                return parseIfStatement();\n            case 'return':\n                return parseReturnStatement();\n            case 'switch':\n                return parseSwitchStatement();\n            case 'throw':\n                return parseThrowStatement();\n            case 'try':\n                return parseTryStatement();\n            case 'var':\n                return parseVariableStatement();\n            case 'while':\n                return parseWhileStatement();\n            case 'with':\n                return parseWithStatement();\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, expr.name)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[expr.name] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[expr.name];\n\n            return {\n                type: Syntax.LabeledStatement,\n                label: expr,\n                body: labeledBody\n            };\n        }\n\n        consumeSemicolon();\n\n        return {\n            type: Syntax.ExpressionStatement,\n            expression: expr\n        };\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;\n\n        expect('{');\n\n        while (index < length) {\n            token = lookahead();\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n\n        return {\n            type: Syntax.BlockStatement,\n            body: sourceElements\n        };\n    }\n\n    function parseFunctionDeclaration() {\n        var id, param, params = [], body, token, stricted, firstRestricted, message, previousStrict, paramSet;\n\n        expectKeyword('function');\n        token = lookahead();\n        id = parseVariableIdentifier();\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        expect('(');\n\n        if (!match(')')) {\n            paramSet = {};\n            while (index < length) {\n                token = lookahead();\n                param = parseVariableIdentifier();\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamName;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                } else if (!firstRestricted) {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                }\n                params.push(param);\n                paramSet[param.name] = true;\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return {\n            type: Syntax.FunctionDeclaration,\n            id: id,\n            params: params,\n            defaults: [],\n            body: body,\n            rest: null,\n            generator: false,\n            expression: false\n        };\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, param, params = [], body, previousStrict, paramSet;\n\n        expectKeyword('function');\n\n        if (!match('(')) {\n            token = lookahead();\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    throwErrorTolerant(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        expect('(');\n\n        if (!match(')')) {\n            paramSet = {};\n            while (index < length) {\n                token = lookahead();\n                param = parseVariableIdentifier();\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamName;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                } else if (!firstRestricted) {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                }\n                params.push(param);\n                paramSet[param.name] = true;\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return {\n            type: Syntax.FunctionExpression,\n            id: id,\n            params: params,\n            defaults: [],\n            body: body,\n            rest: null,\n            generator: false,\n            expression: false\n        };\n    }\n\n    // 14 Program\n\n    function parseSourceElement() {\n        var token = lookahead();\n\n        if (token.type === Token.Keyword) {\n            switch (token.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(token.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (token.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead();\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var program;\n        strict = false;\n        program = {\n            type: Syntax.Program,\n            body: parseSourceElements()\n        };\n        return program;\n    }\n\n    // The following functions are needed only when the option to preserve\n    // the comments is active.\n\n    function addComment(type, value, start, end, loc) {\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (extra.comments.length > 0) {\n            if (extra.comments[extra.comments.length - 1].range[1] > start) {\n                return;\n            }\n        }\n\n        extra.comments.push({\n            type: type,\n            value: value,\n            range: [start, end],\n            loc: loc\n        });\n    }\n\n    function scanComment() {\n        var comment, ch, loc, start, blockComment, lineComment;\n\n        comment = '';\n        blockComment = false;\n        lineComment = false;\n\n        while (index < length) {\n            ch = source[index];\n\n            if (lineComment) {\n                ch = source[index++];\n                if (isLineTerminator(ch)) {\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    lineComment = false;\n                    addComment('Line', comment, start, index - 1, loc);\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                    comment = '';\n                } else if (index >= length) {\n                    lineComment = false;\n                    comment += ch;\n                    loc.end = {\n                        line: lineNumber,\n                        column: length - lineStart\n                    };\n                    addComment('Line', comment, start, length, loc);\n                } else {\n                    comment += ch;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch)) {\n                    if (ch === '\\r' && source[index + 1] === '\\n') {\n                        ++index;\n                        comment += '\\r\\n';\n                    } else {\n                        comment += ch;\n                    }\n                    ++lineNumber;\n                    ++index;\n                    lineStart = index;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    ch = source[index++];\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    comment += ch;\n                    if (ch === '*') {\n                        ch = source[index];\n                        if (ch === '/') {\n                            comment = comment.substr(0, comment.length - 1);\n                            blockComment = false;\n                            ++index;\n                            loc.end = {\n                                line: lineNumber,\n                                column: index - lineStart\n                            };\n                            addComment('Block', comment, start, index, loc);\n                            comment = '';\n                        }\n                    }\n                }\n            } else if (ch === '/') {\n                ch = source[index + 1];\n                if (ch === '/') {\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart\n                        }\n                    };\n                    start = index;\n                    index += 2;\n                    lineComment = true;\n                    if (index >= length) {\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        lineComment = false;\n                        addComment('Line', comment, start, index, loc);\n                    }\n                } else if (ch === '*') {\n                    start = index;\n                    index += 2;\n                    blockComment = true;\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart - 2\n                        }\n                    };\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch ===  '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function filterCommentLocation() {\n        var i, entry, comment, comments = [];\n\n        for (i = 0; i < extra.comments.length; ++i) {\n            entry = extra.comments[i];\n            comment = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                comment.range = entry.range;\n            }\n            if (extra.loc) {\n                comment.loc = entry.loc;\n            }\n            comments.push(comment);\n        }\n\n        extra.comments = comments;\n    }\n\n    function collectToken() {\n        var start, loc, token, range, value;\n\n        skipComment();\n        start = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = extra.advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            range = [token.range[0], token.range[1]];\n            value = sliceSource(token.range[0], token.range[1]);\n            extra.tokens.push({\n                type: TokenName[token.type],\n                value: value,\n                range: range,\n                loc: loc\n            });\n        }\n\n        return token;\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = extra.scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        // Pop the previous token, which is likely '/' or '/='\n        if (extra.tokens.length > 0) {\n            token = extra.tokens[extra.tokens.length - 1];\n            if (token.range[0] === pos && token.type === 'Punctuator') {\n                if (token.value === '/' || token.value === '/=') {\n                    extra.tokens.pop();\n                }\n            }\n        }\n\n        extra.tokens.push({\n            type: 'RegularExpression',\n            value: regex.literal,\n            range: [pos, index],\n            loc: loc\n        });\n\n        return regex;\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function createLiteral(token) {\n        return {\n            type: Syntax.Literal,\n            value: token.value\n        };\n    }\n\n    function createRawLiteral(token) {\n        return {\n            type: Syntax.Literal,\n            value: token.value,\n            raw: sliceSource(token.range[0], token.range[1])\n        };\n    }\n\n    function createLocationMarker() {\n        var marker = {};\n\n        marker.range = [index, index];\n        marker.loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            },\n            end: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        marker.end = function () {\n            this.range[1] = index;\n            this.loc.end.line = lineNumber;\n            this.loc.end.column = index - lineStart;\n        };\n\n        marker.applyGroup = function (node) {\n            if (extra.range) {\n                node.groupRange = [this.range[0], this.range[1]];\n            }\n            if (extra.loc) {\n                node.groupLoc = {\n                    start: {\n                        line: this.loc.start.line,\n                        column: this.loc.start.column\n                    },\n                    end: {\n                        line: this.loc.end.line,\n                        column: this.loc.end.column\n                    }\n                };\n            }\n        };\n\n        marker.apply = function (node) {\n            if (extra.range) {\n                node.range = [this.range[0], this.range[1]];\n            }\n            if (extra.loc) {\n                node.loc = {\n                    start: {\n                        line: this.loc.start.line,\n                        column: this.loc.start.column\n                    },\n                    end: {\n                        line: this.loc.end.line,\n                        column: this.loc.end.column\n                    }\n                };\n            }\n        };\n\n        return marker;\n    }\n\n    function trackGroupExpression() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        marker.end();\n        marker.applyGroup(expr);\n\n        return expr;\n    }\n\n    function trackLeftHandSideExpression() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function trackLeftHandSideExpressionAllowCall() {\n        var marker, expr;\n\n        skipComment();\n        marker = createLocationMarker();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(')) {\n            if (match('(')) {\n                expr = {\n                    type: Syntax.CallExpression,\n                    callee: expr,\n                    'arguments': parseArguments()\n                };\n                marker.end();\n                marker.apply(expr);\n            } else if (match('[')) {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: true,\n                    object: expr,\n                    property: parseComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            } else {\n                expr = {\n                    type: Syntax.MemberExpression,\n                    computed: false,\n                    object: expr,\n                    property: parseNonComputedMember()\n                };\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function filterGroup(node) {\n        var n, i, entry;\n\n        n = (Object.prototype.toString.apply(node) === '[object Array]') ? [] : {};\n        for (i in node) {\n            if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {\n                entry = node[i];\n                if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {\n                    n[i] = entry;\n                } else {\n                    n[i] = filterGroup(entry);\n                }\n            }\n        }\n        return n;\n    }\n\n    function wrapTrackingFunction(range, loc) {\n\n        return function (parseFunction) {\n\n            function isBinary(node) {\n                return node.type === Syntax.LogicalExpression ||\n                    node.type === Syntax.BinaryExpression;\n            }\n\n            function visit(node) {\n                var start, end;\n\n                if (isBinary(node.left)) {\n                    visit(node.left);\n                }\n                if (isBinary(node.right)) {\n                    visit(node.right);\n                }\n\n                if (range) {\n                    if (node.left.groupRange || node.right.groupRange) {\n                        start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];\n                        end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];\n                        node.range = [start, end];\n                    } else if (typeof node.range === 'undefined') {\n                        start = node.left.range[0];\n                        end = node.right.range[1];\n                        node.range = [start, end];\n                    }\n                }\n                if (loc) {\n                    if (node.left.groupLoc || node.right.groupLoc) {\n                        start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;\n                        end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;\n                        node.loc = {\n                            start: start,\n                            end: end\n                        };\n                    } else if (typeof node.loc === 'undefined') {\n                        node.loc = {\n                            start: node.left.loc.start,\n                            end: node.right.loc.end\n                        };\n                    }\n                }\n            }\n\n            return function () {\n                var marker, node;\n\n                skipComment();\n\n                marker = createLocationMarker();\n                node = parseFunction.apply(null, arguments);\n                marker.end();\n\n                if (range && typeof node.range === 'undefined') {\n                    marker.apply(node);\n                }\n\n                if (loc && typeof node.loc === 'undefined') {\n                    marker.apply(node);\n                }\n\n                if (isBinary(node)) {\n                    visit(node);\n                }\n\n                return node;\n            };\n        };\n    }\n\n    function patch() {\n\n        var wrapTracking;\n\n        if (extra.comments) {\n            extra.skipComment = skipComment;\n            skipComment = scanComment;\n        }\n\n        if (extra.raw) {\n            extra.createLiteral = createLiteral;\n            createLiteral = createRawLiteral;\n        }\n\n        if (extra.range || extra.loc) {\n\n            extra.parseGroupExpression = parseGroupExpression;\n            extra.parseLeftHandSideExpression = parseLeftHandSideExpression;\n            extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;\n            parseGroupExpression = trackGroupExpression;\n            parseLeftHandSideExpression = trackLeftHandSideExpression;\n            parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;\n\n            wrapTracking = wrapTrackingFunction(extra.range, extra.loc);\n\n            extra.parseAdditiveExpression = parseAdditiveExpression;\n            extra.parseAssignmentExpression = parseAssignmentExpression;\n            extra.parseBitwiseANDExpression = parseBitwiseANDExpression;\n            extra.parseBitwiseORExpression = parseBitwiseORExpression;\n            extra.parseBitwiseXORExpression = parseBitwiseXORExpression;\n            extra.parseBlock = parseBlock;\n            extra.parseFunctionSourceElements = parseFunctionSourceElements;\n            extra.parseCatchClause = parseCatchClause;\n            extra.parseComputedMember = parseComputedMember;\n            extra.parseConditionalExpression = parseConditionalExpression;\n            extra.parseConstLetDeclaration = parseConstLetDeclaration;\n            extra.parseEqualityExpression = parseEqualityExpression;\n            extra.parseExpression = parseExpression;\n            extra.parseForVariableDeclaration = parseForVariableDeclaration;\n            extra.parseFunctionDeclaration = parseFunctionDeclaration;\n            extra.parseFunctionExpression = parseFunctionExpression;\n            extra.parseLogicalANDExpression = parseLogicalANDExpression;\n            extra.parseLogicalORExpression = parseLogicalORExpression;\n            extra.parseMultiplicativeExpression = parseMultiplicativeExpression;\n            extra.parseNewExpression = parseNewExpression;\n            extra.parseNonComputedProperty = parseNonComputedProperty;\n            extra.parseObjectProperty = parseObjectProperty;\n            extra.parseObjectPropertyKey = parseObjectPropertyKey;\n            extra.parsePostfixExpression = parsePostfixExpression;\n            extra.parsePrimaryExpression = parsePrimaryExpression;\n            extra.parseProgram = parseProgram;\n            extra.parsePropertyFunction = parsePropertyFunction;\n            extra.parseRelationalExpression = parseRelationalExpression;\n            extra.parseStatement = parseStatement;\n            extra.parseShiftExpression = parseShiftExpression;\n            extra.parseSwitchCase = parseSwitchCase;\n            extra.parseUnaryExpression = parseUnaryExpression;\n            extra.parseVariableDeclaration = parseVariableDeclaration;\n            extra.parseVariableIdentifier = parseVariableIdentifier;\n\n            parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);\n            parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);\n            parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);\n            parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);\n            parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);\n            parseBlock = wrapTracking(extra.parseBlock);\n            parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);\n            parseCatchClause = wrapTracking(extra.parseCatchClause);\n            parseComputedMember = wrapTracking(extra.parseComputedMember);\n            parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);\n            parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);\n            parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);\n            parseExpression = wrapTracking(extra.parseExpression);\n            parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);\n            parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);\n            parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);\n            parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);\n            parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);\n            parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);\n            parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);\n            parseNewExpression = wrapTracking(extra.parseNewExpression);\n            parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);\n            parseObjectProperty = wrapTracking(extra.parseObjectProperty);\n            parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);\n            parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);\n            parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);\n            parseProgram = wrapTracking(extra.parseProgram);\n            parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);\n            parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);\n            parseStatement = wrapTracking(extra.parseStatement);\n            parseShiftExpression = wrapTracking(extra.parseShiftExpression);\n            parseSwitchCase = wrapTracking(extra.parseSwitchCase);\n            parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);\n            parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);\n            parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);\n        }\n\n        if (typeof extra.tokens !== 'undefined') {\n            extra.advance = advance;\n            extra.scanRegExp = scanRegExp;\n\n            advance = collectToken;\n            scanRegExp = collectRegex;\n        }\n    }\n\n    function unpatch() {\n        if (typeof extra.skipComment === 'function') {\n            skipComment = extra.skipComment;\n        }\n\n        if (extra.raw) {\n            createLiteral = extra.createLiteral;\n        }\n\n        if (extra.range || extra.loc) {\n            parseAdditiveExpression = extra.parseAdditiveExpression;\n            parseAssignmentExpression = extra.parseAssignmentExpression;\n            parseBitwiseANDExpression = extra.parseBitwiseANDExpression;\n            parseBitwiseORExpression = extra.parseBitwiseORExpression;\n            parseBitwiseXORExpression = extra.parseBitwiseXORExpression;\n            parseBlock = extra.parseBlock;\n            parseFunctionSourceElements = extra.parseFunctionSourceElements;\n            parseCatchClause = extra.parseCatchClause;\n            parseComputedMember = extra.parseComputedMember;\n            parseConditionalExpression = extra.parseConditionalExpression;\n            parseConstLetDeclaration = extra.parseConstLetDeclaration;\n            parseEqualityExpression = extra.parseEqualityExpression;\n            parseExpression = extra.parseExpression;\n            parseForVariableDeclaration = extra.parseForVariableDeclaration;\n            parseFunctionDeclaration = extra.parseFunctionDeclaration;\n            parseFunctionExpression = extra.parseFunctionExpression;\n            parseGroupExpression = extra.parseGroupExpression;\n            parseLeftHandSideExpression = extra.parseLeftHandSideExpression;\n            parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;\n            parseLogicalANDExpression = extra.parseLogicalANDExpression;\n            parseLogicalORExpression = extra.parseLogicalORExpression;\n            parseMultiplicativeExpression = extra.parseMultiplicativeExpression;\n            parseNewExpression = extra.parseNewExpression;\n            parseNonComputedProperty = extra.parseNonComputedProperty;\n            parseObjectProperty = extra.parseObjectProperty;\n            parseObjectPropertyKey = extra.parseObjectPropertyKey;\n            parsePrimaryExpression = extra.parsePrimaryExpression;\n            parsePostfixExpression = extra.parsePostfixExpression;\n            parseProgram = extra.parseProgram;\n            parsePropertyFunction = extra.parsePropertyFunction;\n            parseRelationalExpression = extra.parseRelationalExpression;\n            parseStatement = extra.parseStatement;\n            parseShiftExpression = extra.parseShiftExpression;\n            parseSwitchCase = extra.parseSwitchCase;\n            parseUnaryExpression = extra.parseUnaryExpression;\n            parseVariableDeclaration = extra.parseVariableDeclaration;\n            parseVariableIdentifier = extra.parseVariableIdentifier;\n        }\n\n        if (typeof extra.scanRegExp === 'function') {\n            advance = extra.advance;\n            scanRegExp = extra.scanRegExp;\n        }\n    }\n\n    function stringToArray(str) {\n        var length = str.length,\n            result = [],\n            i;\n        for (i = 0; i < length; ++i) {\n            result[i] = str.charAt(i);\n        }\n        return result;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        buffer = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.raw = (typeof options.raw === 'boolean') && options.raw;\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n\n                // Force accessing the characters via an array.\n                if (typeof source[0] === 'undefined') {\n                    source = stringToArray(code);\n                }\n            }\n        }\n\n        patch();\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                filterCommentLocation();\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n            if (extra.range || extra.loc) {\n                program.body = filterGroup(program.body);\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with package.json.\n    exports.version = '1.0.4';\n\n    exports.parse = parse;\n\n    // Deep copy.\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}