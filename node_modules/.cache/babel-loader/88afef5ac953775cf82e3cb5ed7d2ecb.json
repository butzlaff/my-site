{"ast":null,"code":"'use strict';\n\nconst Packet = require('./packets/packet.js');\n\nconst MAX_PACKET_LENGTH = 16777215;\n\nfunction readPacketLength(b, off) {\n  const b0 = b[off];\n  const b1 = b[off + 1];\n  const b2 = b[off + 2];\n\n  if (b1 + b2 === 0) {\n    return b0;\n  }\n\n  return b0 + (b1 << 8) + (b2 << 16);\n}\n\nclass PacketParser {\n  constructor(onPacket, packetHeaderLength) {\n    // 4 for normal packets, 7 for comprssed protocol packets\n    if (typeof packetHeaderLength === 'undefined') {\n      packetHeaderLength = 4;\n    } // array of last payload chunks\n    // only used when current payload is not complete\n\n\n    this.buffer = []; // total length of chunks on buffer\n\n    this.bufferLength = 0;\n    this.packetHeaderLength = packetHeaderLength; // incomplete header state: number of header bytes received\n\n    this.headerLen = 0; // expected payload length\n\n    this.length = 0;\n    this.largePacketParts = [];\n    this.firstPacketSequenceId = 0;\n    this.onPacket = onPacket;\n    this.execute = PacketParser.prototype.executeStart;\n    this._flushLargePacket = packetHeaderLength === 7 ? this._flushLargePacket7 : this._flushLargePacket4;\n  }\n\n  _flushLargePacket4() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0])); // insert header\n\n    const body = Buffer.concat(this.largePacketParts);\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    this.largePacketParts.length = 0;\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  _flushLargePacket7() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0])); // insert header\n\n    const body = Buffer.concat(this.largePacketParts);\n    this.largePacketParts.length = 0;\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  executeStart(chunk) {\n    let start = 0;\n    const end = chunk.length;\n\n    while (end - start >= 3) {\n      this.length = readPacketLength(chunk, start);\n\n      if (end - start >= this.length + this.packetHeaderLength) {\n        // at least one full packet\n        const sequenceId = chunk[start + 3];\n\n        if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {\n          this.onPacket(new Packet(sequenceId, chunk, start, start + this.packetHeaderLength + this.length));\n        } else {\n          // first large packet - remember it's id\n          if (this.largePacketParts.length === 0) {\n            this.firstPacketSequenceId = sequenceId;\n          }\n\n          this.largePacketParts.push(chunk.slice(start + this.packetHeaderLength, start + this.packetHeaderLength + this.length));\n\n          if (this.length < MAX_PACKET_LENGTH) {\n            this._flushLargePacket();\n          }\n        }\n\n        start += this.packetHeaderLength + this.length;\n      } else {\n        // payload is incomplete\n        this.buffer = [chunk.slice(start + 3, end)];\n        this.bufferLength = end - start - 3;\n        this.execute = PacketParser.prototype.executePayload;\n        return;\n      }\n    }\n\n    if (end - start > 0) {\n      // there is start of length header, but it's not full 3 bytes\n      this.headerLen = end - start; // 1 or 2 bytes\n\n      this.length = chunk[start];\n\n      if (this.headerLen === 2) {\n        this.length = chunk[start] + (chunk[start + 1] << 8);\n        this.execute = PacketParser.prototype.executeHeader3;\n      } else {\n        this.execute = PacketParser.prototype.executeHeader2;\n      }\n    }\n  }\n\n  executePayload(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    const remainingPayload = this.length - this.bufferLength + this.packetHeaderLength - 3;\n\n    if (end - start >= remainingPayload) {\n      // last chunk for payload\n      const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);\n      let offset = 3;\n\n      for (let i = 0; i < this.buffer.length; ++i) {\n        this.buffer[i].copy(payload, offset);\n        offset += this.buffer[i].length;\n      }\n\n      chunk.copy(payload, offset, start, start + remainingPayload);\n      const sequenceId = payload[3];\n\n      if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {\n        this.onPacket(new Packet(sequenceId, payload, 0, this.length + this.packetHeaderLength));\n      } else {\n        // first large packet - remember it's id\n        if (this.largePacketParts.length === 0) {\n          this.firstPacketSequenceId = sequenceId;\n        }\n\n        this.largePacketParts.push(payload.slice(this.packetHeaderLength, this.packetHeaderLength + this.length));\n\n        if (this.length < MAX_PACKET_LENGTH) {\n          this._flushLargePacket();\n        }\n      }\n\n      this.buffer = [];\n      this.bufferLength = 0;\n      this.execute = PacketParser.prototype.executeStart;\n      start += remainingPayload;\n\n      if (end - start > 0) {\n        return this.execute(chunk.slice(start, end));\n      }\n    } else {\n      this.buffer.push(chunk);\n      this.bufferLength += chunk.length;\n    }\n\n    return null;\n  }\n\n  executeHeader2(chunk) {\n    this.length += chunk[0] << 8;\n\n    if (chunk.length > 1) {\n      this.length += chunk[1] << 16;\n      this.execute = PacketParser.prototype.executePayload;\n      return this.executePayload(chunk.slice(2));\n    }\n\n    this.execute = PacketParser.prototype.executeHeader3;\n    return null;\n  }\n\n  executeHeader3(chunk) {\n    this.length += chunk[0] << 16;\n    this.execute = PacketParser.prototype.executePayload;\n    return this.executePayload(chunk.slice(1));\n  }\n\n}\n\nmodule.exports = PacketParser;","map":{"version":3,"names":["Packet","require","MAX_PACKET_LENGTH","readPacketLength","b","off","b0","b1","b2","PacketParser","constructor","onPacket","packetHeaderLength","buffer","bufferLength","headerLen","length","largePacketParts","firstPacketSequenceId","execute","prototype","executeStart","_flushLargePacket","_flushLargePacket7","_flushLargePacket4","numPackets","unshift","Buffer","from","body","concat","packet","chunk","start","end","sequenceId","push","slice","executePayload","executeHeader3","executeHeader2","remainingPayload","payload","allocUnsafe","offset","i","copy","module","exports"],"sources":["/home/emilio/Ãrea de Trabalho/OneBitCode-aulas/REACT/site-react-login-live/react-controlledForms/node_modules/mysql2/lib/packet_parser.js"],"sourcesContent":["'use strict';\n\nconst Packet = require('./packets/packet.js');\n\nconst MAX_PACKET_LENGTH = 16777215;\n\nfunction readPacketLength(b, off) {\n  const b0 = b[off];\n  const b1 = b[off + 1];\n  const b2 = b[off + 2];\n  if (b1 + b2 === 0) {\n    return b0;\n  }\n  return b0 + (b1 << 8) + (b2 << 16);\n}\n\nclass PacketParser {\n  constructor(onPacket, packetHeaderLength) {\n    // 4 for normal packets, 7 for comprssed protocol packets\n    if (typeof packetHeaderLength === 'undefined') {\n      packetHeaderLength = 4;\n    }\n    // array of last payload chunks\n    // only used when current payload is not complete\n    this.buffer = [];\n    // total length of chunks on buffer\n    this.bufferLength = 0;\n    this.packetHeaderLength = packetHeaderLength;\n    // incomplete header state: number of header bytes received\n    this.headerLen = 0;\n    // expected payload length\n    this.length = 0;\n    this.largePacketParts = [];\n    this.firstPacketSequenceId = 0;\n    this.onPacket = onPacket;\n    this.execute = PacketParser.prototype.executeStart;\n    this._flushLargePacket =\n      packetHeaderLength === 7\n        ? this._flushLargePacket7\n        : this._flushLargePacket4;\n  }\n\n  _flushLargePacket4() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0])); // insert header\n    const body = Buffer.concat(this.largePacketParts);\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    this.largePacketParts.length = 0;\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  _flushLargePacket7() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0])); // insert header\n    const body = Buffer.concat(this.largePacketParts);\n    this.largePacketParts.length = 0;\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  executeStart(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    while (end - start >= 3) {\n      this.length = readPacketLength(chunk, start);\n      if (end - start >= this.length + this.packetHeaderLength) {\n        // at least one full packet\n        const sequenceId = chunk[start + 3];\n        if (\n          this.length < MAX_PACKET_LENGTH &&\n          this.largePacketParts.length === 0\n        ) {\n          this.onPacket(\n            new Packet(\n              sequenceId,\n              chunk,\n              start,\n              start + this.packetHeaderLength + this.length\n            )\n          );\n        } else {\n          // first large packet - remember it's id\n          if (this.largePacketParts.length === 0) {\n            this.firstPacketSequenceId = sequenceId;\n          }\n          this.largePacketParts.push(\n            chunk.slice(\n              start + this.packetHeaderLength,\n              start + this.packetHeaderLength + this.length\n            )\n          );\n          if (this.length < MAX_PACKET_LENGTH) {\n            this._flushLargePacket();\n          }\n        }\n        start += this.packetHeaderLength + this.length;\n      } else {\n        // payload is incomplete\n        this.buffer = [chunk.slice(start + 3, end)];\n        this.bufferLength = end - start - 3;\n        this.execute = PacketParser.prototype.executePayload;\n        return;\n      }\n    }\n    if (end - start > 0) {\n      // there is start of length header, but it's not full 3 bytes\n      this.headerLen = end - start; // 1 or 2 bytes\n      this.length = chunk[start];\n      if (this.headerLen === 2) {\n        this.length = chunk[start] + (chunk[start + 1] << 8);\n        this.execute = PacketParser.prototype.executeHeader3;\n      } else {\n        this.execute = PacketParser.prototype.executeHeader2;\n      }\n    }\n  }\n\n  executePayload(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    const remainingPayload =\n      this.length - this.bufferLength + this.packetHeaderLength - 3;\n    if (end - start >= remainingPayload) {\n      // last chunk for payload\n      const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);\n      let offset = 3;\n      for (let i = 0; i < this.buffer.length; ++i) {\n        this.buffer[i].copy(payload, offset);\n        offset += this.buffer[i].length;\n      }\n      chunk.copy(payload, offset, start, start + remainingPayload);\n      const sequenceId = payload[3];\n      if (\n        this.length < MAX_PACKET_LENGTH &&\n        this.largePacketParts.length === 0\n      ) {\n        this.onPacket(\n          new Packet(\n            sequenceId,\n            payload,\n            0,\n            this.length + this.packetHeaderLength\n          )\n        );\n      } else {\n        // first large packet - remember it's id\n        if (this.largePacketParts.length === 0) {\n          this.firstPacketSequenceId = sequenceId;\n        }\n        this.largePacketParts.push(\n          payload.slice(\n            this.packetHeaderLength,\n            this.packetHeaderLength + this.length\n          )\n        );\n        if (this.length < MAX_PACKET_LENGTH) {\n          this._flushLargePacket();\n        }\n      }\n      this.buffer = [];\n      this.bufferLength = 0;\n      this.execute = PacketParser.prototype.executeStart;\n      start += remainingPayload;\n      if (end - start > 0) {\n        return this.execute(chunk.slice(start, end));\n      }\n    } else {\n      this.buffer.push(chunk);\n      this.bufferLength += chunk.length;\n    }\n    return null;\n  }\n\n  executeHeader2(chunk) {\n    this.length += chunk[0] << 8;\n    if (chunk.length > 1) {\n      this.length += chunk[1] << 16;\n      this.execute = PacketParser.prototype.executePayload;\n      return this.executePayload(chunk.slice(2));\n    } \n    this.execute = PacketParser.prototype.executeHeader3;\n    \n    return null;\n  }\n\n  executeHeader3(chunk) {\n    this.length += chunk[0] << 16;\n    this.execute = PacketParser.prototype.executePayload;\n    return this.executePayload(chunk.slice(1));\n  }\n}\n\nmodule.exports = PacketParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}