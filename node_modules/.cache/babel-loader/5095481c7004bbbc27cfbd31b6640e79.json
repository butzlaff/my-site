{"ast":null,"code":"// This file was modified by Oracle on June 17, 2021.\n// Handshake errors are now maked as fatal and the corresponding events are\n// emitted in the command instance itself.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n'use strict';\n\nconst Command = require('./command.js');\n\nconst Packets = require('../packets/index.js');\n\nconst ClientConstants = require('../constants/client.js');\n\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\n\nconst auth41 = require('../auth_41.js');\n\nfunction flagNames(flags) {\n  const res = [];\n\n  for (const c in ClientConstants) {\n    if (flags & ClientConstants[c]) {\n      res.push(c.replace(/_/g, ' ').toLowerCase());\n    }\n  }\n\n  return res;\n}\n\nclass ClientHandshake extends Command {\n  constructor(clientFlags) {\n    super();\n    this.handshake = null;\n    this.clientFlags = clientFlags;\n  }\n\n  start() {\n    return ClientHandshake.prototype.handshakeInit;\n  }\n\n  sendSSLRequest(connection) {\n    const sslRequest = new Packets.SSLRequest(this.clientFlags, connection.config.charsetNumber);\n    connection.writePacket(sslRequest.toPacket());\n  }\n\n  sendCredentials(connection) {\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('Sending handshake packet: flags:%d=(%s)', this.clientFlags, flagNames(this.clientFlags).join(', '));\n    }\n\n    this.user = connection.config.user;\n    this.password = connection.config.password;\n    this.passwordSha1 = connection.config.passwordSha1;\n    this.database = connection.config.database;\n    this.autPluginName = this.handshake.autPluginName;\n    const handshakeResponse = new Packets.HandshakeResponse({\n      flags: this.clientFlags,\n      user: this.user,\n      database: this.database,\n      password: this.password,\n      passwordSha1: this.passwordSha1,\n      charsetNumber: connection.config.charsetNumber,\n      authPluginData1: this.handshake.authPluginData1,\n      authPluginData2: this.handshake.authPluginData2,\n      compress: connection.config.compress,\n      connectAttributes: connection.config.connectAttributes\n    });\n    connection.writePacket(handshakeResponse.toPacket());\n  }\n\n  calculateNativePasswordAuthToken(authPluginData) {\n    // TODO: dont split into authPluginData1 and authPluginData2, instead join when 1 & 2 received\n    const authPluginData1 = authPluginData.slice(0, 8);\n    const authPluginData2 = authPluginData.slice(8, 20);\n    let authToken;\n\n    if (this.passwordSha1) {\n      authToken = auth41.calculateTokenFromPasswordSha(this.passwordSha1, authPluginData1, authPluginData2);\n    } else {\n      authToken = auth41.calculateToken(this.password, authPluginData1, authPluginData2);\n    }\n\n    return authToken;\n  }\n\n  handshakeInit(helloPacket, connection) {\n    this.on('error', e => {\n      connection._fatalError = e;\n      connection._protocolError = e;\n    });\n    this.handshake = Packets.Handshake.fromPacket(helloPacket);\n\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('Server hello packet: capability flags:%d=(%s)', this.handshake.capabilityFlags, flagNames(this.handshake.capabilityFlags).join(', '));\n    }\n\n    connection.serverCapabilityFlags = this.handshake.capabilityFlags;\n    connection.serverEncoding = CharsetToEncoding[this.handshake.characterSet];\n    connection.connectionId = this.handshake.connectionId;\n    const serverSSLSupport = this.handshake.capabilityFlags & ClientConstants.SSL; // use compression only if requested by client and supported by server\n\n    connection.config.compress = connection.config.compress && this.handshake.capabilityFlags & ClientConstants.COMPRESS;\n    this.clientFlags = this.clientFlags | connection.config.compress;\n\n    if (connection.config.ssl) {\n      // client requires SSL but server does not support it\n      if (!serverSSLSupport) {\n        const err = new Error('Server does not support secure connnection');\n        err.code = 'HANDSHAKE_NO_SSL_SUPPORT';\n        err.fatal = true;\n        this.emit('error', err);\n        return false;\n      } // send ssl upgrade request and immediately upgrade connection to secure\n\n\n      this.clientFlags |= ClientConstants.SSL;\n      this.sendSSLRequest(connection);\n      connection.startTLS(err => {\n        // after connection is secure\n        if (err) {\n          // SSL negotiation error are fatal\n          err.code = 'HANDSHAKE_SSL_ERROR';\n          err.fatal = true;\n          this.emit('error', err);\n          return;\n        } // rest of communication is encrypted\n\n\n        this.sendCredentials(connection);\n      });\n    } else {\n      this.sendCredentials(connection);\n    }\n\n    return ClientHandshake.prototype.handshakeResult;\n  }\n\n  handshakeResult(packet, connection) {\n    const marker = packet.peekByte();\n\n    if (marker === 0xfe || marker === 1) {\n      const authSwitch = require('./auth_switch');\n\n      try {\n        if (marker === 1) {\n          authSwitch.authSwitchRequestMoreData(packet, connection, this);\n        } else {\n          authSwitch.authSwitchRequest(packet, connection, this);\n        }\n\n        return ClientHandshake.prototype.handshakeResult;\n      } catch (err) {\n        // Authentication errors are fatal\n        err.code = 'AUTH_SWITCH_PLUGIN_ERROR';\n        err.fatal = true;\n\n        if (this.onResult) {\n          this.onResult(err);\n        } else {\n          this.emit('error', err);\n        }\n\n        return null;\n      }\n    }\n\n    if (marker !== 0) {\n      const err = new Error('Unexpected packet during handshake phase'); // Unknown handshake errors are fatal\n\n      err.code = 'HANDSHAKE_UNKNOWN_ERROR';\n      err.fatal = true;\n\n      if (this.onResult) {\n        this.onResult(err);\n      } else {\n        this.emit('error', err);\n      }\n\n      return null;\n    } // this should be called from ClientHandshake command only\n    // and skipped when called from ChangeUser command\n\n\n    if (!connection.authorized) {\n      connection.authorized = true;\n\n      if (connection.config.compress) {\n        const enableCompression = require('../compressed_protocol.js').enableCompression;\n\n        enableCompression(connection);\n      }\n    }\n\n    if (this.onResult) {\n      this.onResult(null);\n    }\n\n    return null;\n  }\n\n}\n\nmodule.exports = ClientHandshake;","map":{"version":3,"names":["Command","require","Packets","ClientConstants","CharsetToEncoding","auth41","flagNames","flags","res","c","push","replace","toLowerCase","ClientHandshake","constructor","clientFlags","handshake","start","prototype","handshakeInit","sendSSLRequest","connection","sslRequest","SSLRequest","config","charsetNumber","writePacket","toPacket","sendCredentials","debug","console","log","join","user","password","passwordSha1","database","autPluginName","handshakeResponse","HandshakeResponse","authPluginData1","authPluginData2","compress","connectAttributes","calculateNativePasswordAuthToken","authPluginData","slice","authToken","calculateTokenFromPasswordSha","calculateToken","helloPacket","on","e","_fatalError","_protocolError","Handshake","fromPacket","capabilityFlags","serverCapabilityFlags","serverEncoding","characterSet","connectionId","serverSSLSupport","SSL","COMPRESS","ssl","err","Error","code","fatal","emit","startTLS","handshakeResult","packet","marker","peekByte","authSwitch","authSwitchRequestMoreData","authSwitchRequest","onResult","authorized","enableCompression","module","exports"],"sources":["/home/emilio/√Årea de Trabalho/OneBitCode-aulas/REACT/site-react-login-live/react-controlledForms/node_modules/mysql2/lib/commands/client_handshake.js"],"sourcesContent":["// This file was modified by Oracle on June 17, 2021.\n// Handshake errors are now maked as fatal and the corresponding events are\n// emitted in the command instance itself.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n\n'use strict';\n\nconst Command = require('./command.js');\nconst Packets = require('../packets/index.js');\nconst ClientConstants = require('../constants/client.js');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\nconst auth41 = require('../auth_41.js');\n\nfunction flagNames(flags) {\n  const res = [];\n  for (const c in ClientConstants) {\n    if (flags & ClientConstants[c]) {\n      res.push(c.replace(/_/g, ' ').toLowerCase());\n    }\n  }\n  return res;\n}\n\nclass ClientHandshake extends Command {\n  constructor(clientFlags) {\n    super();\n    this.handshake = null;\n    this.clientFlags = clientFlags;\n  }\n\n  start() {\n    return ClientHandshake.prototype.handshakeInit;\n  }\n\n  sendSSLRequest(connection) {\n    const sslRequest = new Packets.SSLRequest(\n      this.clientFlags,\n      connection.config.charsetNumber\n    );\n    connection.writePacket(sslRequest.toPacket());\n  }\n\n  sendCredentials(connection) {\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log(\n        'Sending handshake packet: flags:%d=(%s)',\n        this.clientFlags,\n        flagNames(this.clientFlags).join(', ')\n      );\n    }\n    this.user = connection.config.user;\n    this.password = connection.config.password;\n    this.passwordSha1 = connection.config.passwordSha1;\n    this.database = connection.config.database;\n    this.autPluginName = this.handshake.autPluginName;\n    const handshakeResponse = new Packets.HandshakeResponse({\n      flags: this.clientFlags,\n      user: this.user,\n      database: this.database,\n      password: this.password,\n      passwordSha1: this.passwordSha1,\n      charsetNumber: connection.config.charsetNumber,\n      authPluginData1: this.handshake.authPluginData1,\n      authPluginData2: this.handshake.authPluginData2,\n      compress: connection.config.compress,\n      connectAttributes: connection.config.connectAttributes\n    });\n    connection.writePacket(handshakeResponse.toPacket());\n  }\n\n  calculateNativePasswordAuthToken(authPluginData) {\n    // TODO: dont split into authPluginData1 and authPluginData2, instead join when 1 & 2 received\n    const authPluginData1 = authPluginData.slice(0, 8);\n    const authPluginData2 = authPluginData.slice(8, 20);\n    let authToken;\n    if (this.passwordSha1) {\n      authToken = auth41.calculateTokenFromPasswordSha(\n        this.passwordSha1,\n        authPluginData1,\n        authPluginData2\n      );\n    } else {\n      authToken = auth41.calculateToken(\n        this.password,\n        authPluginData1,\n        authPluginData2\n      );\n    }\n    return authToken;\n  }\n\n  handshakeInit(helloPacket, connection) {\n    this.on('error', e => {\n      connection._fatalError = e;\n      connection._protocolError = e;\n    });\n    this.handshake = Packets.Handshake.fromPacket(helloPacket);\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log(\n        'Server hello packet: capability flags:%d=(%s)',\n        this.handshake.capabilityFlags,\n        flagNames(this.handshake.capabilityFlags).join(', ')\n      );\n    }\n    connection.serverCapabilityFlags = this.handshake.capabilityFlags;\n    connection.serverEncoding = CharsetToEncoding[this.handshake.characterSet];\n    connection.connectionId = this.handshake.connectionId;\n    const serverSSLSupport =\n      this.handshake.capabilityFlags & ClientConstants.SSL;\n    // use compression only if requested by client and supported by server\n    connection.config.compress =\n      connection.config.compress &&\n      this.handshake.capabilityFlags & ClientConstants.COMPRESS;\n    this.clientFlags = this.clientFlags | connection.config.compress;\n    if (connection.config.ssl) {\n      // client requires SSL but server does not support it\n      if (!serverSSLSupport) {\n        const err = new Error('Server does not support secure connnection');\n        err.code = 'HANDSHAKE_NO_SSL_SUPPORT';\n        err.fatal = true;\n        this.emit('error', err);\n        return false;\n      }\n      // send ssl upgrade request and immediately upgrade connection to secure\n      this.clientFlags |= ClientConstants.SSL;\n      this.sendSSLRequest(connection);\n      connection.startTLS(err => {\n        // after connection is secure\n        if (err) {\n          // SSL negotiation error are fatal\n          err.code = 'HANDSHAKE_SSL_ERROR';\n          err.fatal = true;\n          this.emit('error', err);\n          return;\n        }\n        // rest of communication is encrypted\n        this.sendCredentials(connection);\n      });\n    } else {\n      this.sendCredentials(connection);\n    }\n    return ClientHandshake.prototype.handshakeResult;\n  }\n\n  handshakeResult(packet, connection) {\n    const marker = packet.peekByte();\n    if (marker === 0xfe || marker === 1) {\n      const authSwitch = require('./auth_switch');\n      try {\n        if (marker === 1) {\n          authSwitch.authSwitchRequestMoreData(packet, connection, this);\n        } else {\n          authSwitch.authSwitchRequest(packet, connection, this);\n        }\n        return ClientHandshake.prototype.handshakeResult;\n      } catch (err) {\n        // Authentication errors are fatal\n        err.code = 'AUTH_SWITCH_PLUGIN_ERROR';\n        err.fatal = true;\n\n        if (this.onResult) {\n          this.onResult(err);\n        } else {\n          this.emit('error', err);\n        }\n        return null;\n      }\n    }\n    if (marker !== 0) {\n      const err = new Error('Unexpected packet during handshake phase');\n      // Unknown handshake errors are fatal\n      err.code = 'HANDSHAKE_UNKNOWN_ERROR';\n      err.fatal = true;\n\n      if (this.onResult) {\n        this.onResult(err);\n      } else {\n        this.emit('error', err);\n      }\n      return null;\n    }\n    // this should be called from ClientHandshake command only\n    // and skipped when called from ChangeUser command\n    if (!connection.authorized) {\n      connection.authorized = true;\n      if (connection.config.compress) {\n        const enableCompression = require('../compressed_protocol.js')\n          .enableCompression;\n        enableCompression(connection);\n      }\n    }\n    if (this.onResult) {\n      this.onResult(null);\n    }\n    return null;\n  }\n}\nmodule.exports = ClientHandshake;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}