{"ast":null,"code":"// This file was modified by Oracle on June 1, 2021.\n// A comment describing some changes in the strict default SQL mode regarding\n// non-standard dates was introduced.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n'use strict';\n\nconst ErrorCodeToName = require('../constants/errors.js');\n\nconst NativeBuffer = require('buffer').Buffer;\n\nconst Long = require('long');\n\nconst StringParser = require('../parsers/string.js');\n\nconst INVALID_DATE = new Date(NaN); // this is nearly duplicate of previous function so generated code is not slower\n// due to \"if (dateStrings)\" branching\n\nconst pad = '000000000000';\n\nfunction leftPad(num, value) {\n  const s = value.toString(); // if we don't need to pad\n\n  if (s.length >= num) {\n    return s;\n  }\n\n  return (pad + s).slice(-num);\n} // The whole reason parse* function below exist\n// is because String creation is relatively expensive (at least with V8), and if we have\n// a buffer with \"12345\" content ideally we would like to bypass intermediate\n// \"12345\" string creation and directly build 12345 number out of\n// <Buffer 31 32 33 34 35> data.\n// In my benchmarks the difference is ~25M 8-digit numbers per second vs\n// 4.5 M using Number(packet.readLengthCodedString())\n// not used when size is close to max precision as series of *10 accumulate error\n// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))\n// In the futire node version if speed difference is smaller parse* functions might be removed\n// don't consider them as Packet public API\n\n\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0); // TODO: handle E notation\n\nconst dot = '.'.charCodeAt(0);\nconst exponent = 'e'.charCodeAt(0);\nconst exponentCapital = 'E'.charCodeAt(0);\n\nclass Packet {\n  constructor(id, buffer, start, end) {\n    // hot path, enable checks when testing only\n    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')\n    //  throw new Error('invalid packet');\n    this.sequenceId = id;\n    this.numPackets = 1;\n    this.buffer = buffer;\n    this.start = start;\n    this.offset = start + 4;\n    this.end = end;\n  } // ==============================\n  // readers\n  // ==============================\n\n\n  reset() {\n    this.offset = this.start + 4;\n  }\n\n  length() {\n    return this.end - this.start;\n  }\n\n  slice() {\n    return this.buffer.slice(this.start, this.end);\n  }\n\n  dump() {\n    // eslint-disable-next-line no-console\n    console.log([this.buffer.asciiSlice(this.start, this.end)], this.buffer.slice(this.start, this.end), this.length(), this.sequenceId);\n  }\n\n  haveMoreData() {\n    return this.end > this.offset;\n  }\n\n  skip(num) {\n    this.offset += num;\n  }\n\n  readInt8() {\n    return this.buffer[this.offset++];\n  }\n\n  readInt16() {\n    this.offset += 2;\n    return this.buffer.readUInt16LE(this.offset - 2);\n  }\n\n  readInt24() {\n    return this.readInt16() + (this.readInt8() << 16);\n  }\n\n  readInt32() {\n    this.offset += 4;\n    return this.buffer.readUInt32LE(this.offset - 4);\n  }\n\n  readSInt8() {\n    return this.buffer.readInt8(this.offset++);\n  }\n\n  readSInt16() {\n    this.offset += 2;\n    return this.buffer.readInt16LE(this.offset - 2);\n  }\n\n  readSInt32() {\n    this.offset += 4;\n    return this.buffer.readInt32LE(this.offset - 4);\n  }\n\n  readInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const l = new Long(word0, word1, true);\n    return l.toNumber();\n  }\n\n  readSInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n\n    if (!(word1 & 0x80000000)) {\n      return word0 + 0x100000000 * word1;\n    }\n\n    const l = new Long(word0, word1, false);\n    return l.toNumber();\n  }\n\n  readInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, true);\n    return res.toString();\n  }\n\n  readSInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, false);\n    return res.toString();\n  }\n\n  readInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, true);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  readSInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, false);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  isEOF() {\n    return this.buffer[this.offset] === 0xfe && this.length() < 13;\n  }\n\n  eofStatusFlags() {\n    return this.buffer.readInt16LE(this.offset + 3);\n  }\n\n  eofWarningCount() {\n    return this.buffer.readInt16LE(this.offset + 1);\n  }\n\n  readLengthCodedNumber(bigNumberStrings, signed) {\n    const byte1 = this.buffer[this.offset++];\n\n    if (byte1 < 251) {\n      return byte1;\n    }\n\n    return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);\n  }\n\n  readLengthCodedNumberSigned(bigNumberStrings) {\n    return this.readLengthCodedNumber(bigNumberStrings, true);\n  }\n\n  readLengthCodedNumberExt(tag, bigNumberStrings, signed) {\n    let word0, word1;\n    let res;\n\n    if (tag === 0xfb) {\n      return null;\n    }\n\n    if (tag === 0xfc) {\n      return this.readInt8() + (this.readInt8() << 8);\n    }\n\n    if (tag === 0xfd) {\n      return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);\n    }\n\n    if (tag === 0xfe) {\n      // TODO: check version\n      // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.\n      word0 = this.readInt32();\n      word1 = this.readInt32();\n\n      if (word1 === 0) {\n        return word0; // don't convert to float if possible\n      }\n\n      if (word1 < 2097152) {\n        // max exact float point int, 2^52 / 2^32\n        return word1 * 0x100000000 + word0;\n      }\n\n      res = new Long(word0, word1, !signed); // Long need unsigned\n\n      const resNumber = res.toNumber();\n      const resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return bigNumberStrings ? resString : res;\n    } // eslint-disable-next-line no-console\n\n\n    console.trace();\n    throw new Error(`Should not reach here: ${tag}`);\n  }\n\n  readFloat() {\n    const res = this.buffer.readFloatLE(this.offset);\n    this.offset += 4;\n    return res;\n  }\n\n  readDouble() {\n    const res = this.buffer.readDoubleLE(this.offset);\n    this.offset += 8;\n    return res;\n  }\n\n  readBuffer(len) {\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n\n    this.offset += len;\n    return this.buffer.slice(this.offset - len, this.offset);\n  } // DATE, DATETIME and TIMESTAMP\n\n\n  readDateTime(timezone) {\n    if (!timezone || timezone === 'Z' || timezone === 'local') {\n      const length = this.readInt8();\n\n      if (length === 0xfb) {\n        return null;\n      }\n\n      let y = 0;\n      let m = 0;\n      let d = 0;\n      let H = 0;\n      let M = 0;\n      let S = 0;\n      let ms = 0;\n\n      if (length > 3) {\n        y = this.readInt16();\n        m = this.readInt8();\n        d = this.readInt8();\n      }\n\n      if (length > 6) {\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n      }\n\n      if (length > 10) {\n        ms = this.readInt32() / 1000;\n      } // NO_ZERO_DATE mode and NO_ZERO_IN_DATE mode are part of the strict\n      // default SQL mode used by MySQL 8.0. This means that non-standard\n      // dates like '0000-00-00' become NULL. For older versions and other\n      // possible MySQL flavours we still need to account for the\n      // non-standard behaviour.\n\n\n      if (y + m + d + H + M + S + ms === 0) {\n        return INVALID_DATE;\n      }\n\n      if (timezone === 'Z') {\n        return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));\n      }\n\n      return new Date(y, m - 1, d, H, M, S, ms);\n    }\n\n    let str = this.readDateTimeString(6, 'T');\n\n    if (str.length === 10) {\n      str += 'T00:00:00';\n    }\n\n    return new Date(str + timezone);\n  }\n\n  readDateTimeString(decimals, timeSep) {\n    const length = this.readInt8();\n    let y = 0;\n    let m = 0;\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    let str;\n\n    if (length > 3) {\n      y = this.readInt16();\n      m = this.readInt8();\n      d = this.readInt8();\n      str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');\n    }\n\n    if (length > 6) {\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n      str += `${timeSep || ' '}${[leftPad(2, H), leftPad(2, M), leftPad(2, S)].join(':')}`;\n    }\n\n    if (length > 10) {\n      ms = this.readInt32();\n      str += '.';\n\n      if (decimals) {\n        ms = leftPad(6, ms);\n\n        if (ms.length > decimals) {\n          ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here\n        }\n      }\n\n      str += ms;\n    }\n\n    return str;\n  } // TIME - value as a string, Can be negative\n\n\n  readTimeString(convertTtoMs) {\n    const length = this.readInt8();\n\n    if (length === 0) {\n      return '00:00:00';\n    }\n\n    const sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte\n\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n\n    if (length > 6) {\n      d = this.readInt32();\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n    }\n\n    if (length > 10) {\n      ms = this.readInt32();\n    }\n\n    if (convertTtoMs) {\n      H += d * 24;\n      M += H * 60;\n      S += M * 60;\n      ms += S * 1000;\n      ms *= sign;\n      return ms;\n    } // Format follows mySQL TIME format ([-][h]hh:mm:ss[.u[u[u[u[u[u]]]]]])\n    // For positive times below 24 hours, this makes it equal to ISO 8601 times\n\n\n    return (sign === -1 ? '-' : '') + [leftPad(2, d * 24 + H), leftPad(2, M), leftPad(2, S)].join(':') + (ms ? `.${ms}`.replace(/0+$/, '') : '');\n  }\n\n  readLengthCodedString(encoding) {\n    const len = this.readLengthCodedNumber(); // TODO: check manually first byte here to avoid polymorphic return type?\n\n    if (len === null) {\n      return null;\n    }\n\n    this.offset += len; // TODO: Use characterSetCode to get proper encoding\n    // https://github.com/sidorares/node-mysql2/pull/374\n\n    return StringParser.decode(this.buffer, encoding, this.offset - len, this.offset);\n  }\n\n  readLengthCodedBuffer() {\n    const len = this.readLengthCodedNumber();\n\n    if (len === null) {\n      return null;\n    }\n\n    return this.readBuffer(len);\n  }\n\n  readNullTerminatedString(encoding) {\n    const start = this.offset;\n    let end = this.offset;\n\n    while (this.buffer[end]) {\n      end = end + 1; // TODO: handle OOB check\n    }\n\n    this.offset = end + 1;\n    return StringParser.decode(this.buffer, encoding, start, end);\n  } // TODO reuse?\n\n\n  readString(len, encoding) {\n    if (typeof len === 'string' && typeof encoding === 'undefined') {\n      encoding = len;\n      len = undefined;\n    }\n\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n\n    this.offset += len;\n    return StringParser.decode(this.buffer, encoding, this.offset - len, this.offset);\n  }\n\n  parseInt(len, supportBigNumbers) {\n    if (len === null) {\n      return null;\n    }\n\n    if (len >= 14 && !supportBigNumbers) {\n      const s = this.buffer.toString('ascii', this.offset, this.offset + len);\n      this.offset += len;\n      return Number(s);\n    }\n\n    let result = 0;\n    const start = this.offset;\n    const end = this.offset + len;\n    let sign = 1;\n\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    } // max precise int is 9007199254740992\n\n\n    let str;\n    const numDigits = end - this.offset;\n\n    if (supportBigNumbers) {\n      if (numDigits >= 15) {\n        str = this.readString(end - this.offset, 'binary');\n        result = parseInt(str, 10);\n\n        if (result.toString() === str) {\n          return sign * result;\n        }\n\n        return sign === -1 ? `-${str}` : str;\n      }\n\n      if (numDigits > 16) {\n        str = this.readString(end - this.offset);\n        return sign === -1 ? `-${str}` : str;\n      }\n    }\n\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n\n    const num = result * sign;\n\n    if (!supportBigNumbers) {\n      return num;\n    }\n\n    str = this.buffer.toString('ascii', start, end);\n\n    if (num.toString() === str) {\n      return num;\n    }\n\n    return str;\n  } // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER\n  // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be\n  // different from what you would get from Number(inputNumberAsString)\n  // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString\n\n\n  parseIntNoBigCheck(len) {\n    if (len === null) {\n      return null;\n    }\n\n    let result = 0;\n    const end = this.offset + len;\n    let sign = 1;\n\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n\n    return result * sign;\n  } // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js\n\n\n  parseGeometryValue() {\n    const buffer = this.readLengthCodedBuffer();\n    let offset = 4;\n\n    if (buffer === null || !buffer.length) {\n      return null;\n    }\n\n    function parseGeometry() {\n      let x, y, i, j, numPoints, line;\n      let result = null;\n      const byteOrder = buffer.readUInt8(offset);\n      offset += 1;\n      const wkbType = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n      offset += 4;\n\n      switch (wkbType) {\n        case 1:\n          // WKBPoint\n          x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n          offset += 8;\n          y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n          offset += 8;\n          result = {\n            x: x,\n            y: y\n          };\n          break;\n\n        case 2:\n          // WKBLineString\n          numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n\n          for (i = numPoints; i > 0; i--) {\n            x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            result.push({\n              x: x,\n              y: y\n            });\n          }\n\n          break;\n\n        case 3:\n          // WKBPolygon\n          // eslint-disable-next-line no-case-declarations\n          const numRings = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n\n          for (i = numRings; i > 0; i--) {\n            numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n            offset += 4;\n            line = [];\n\n            for (j = numPoints; j > 0; j--) {\n              x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              line.push({\n                x: x,\n                y: y\n              });\n            }\n\n            result.push(line);\n          }\n\n          break;\n\n        case 4: // WKBMultiPoint\n\n        case 5: // WKBMultiLineString\n\n        case 6: // WKBMultiPolygon\n\n        case 7:\n          // WKBGeometryCollection\n          // eslint-disable-next-line no-case-declarations\n          const num = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n\n          for (i = num; i > 0; i--) {\n            result.push(parseGeometry());\n          }\n\n          break;\n      }\n\n      return result;\n    }\n\n    return parseGeometry();\n  }\n\n  parseDate(timezone) {\n    const strLen = this.readLengthCodedNumber();\n\n    if (strLen === null) {\n      return null;\n    }\n\n    if (strLen !== 10) {\n      // we expect only YYYY-MM-DD here.\n      // if for some reason it's not the case return invalid date\n      return new Date(NaN);\n    }\n\n    const y = this.parseInt(4);\n    this.offset++; // -\n\n    const m = this.parseInt(2);\n    this.offset++; // -\n\n    const d = this.parseInt(2);\n\n    if (!timezone || timezone === 'local') {\n      return new Date(y, m - 1, d);\n    }\n\n    if (timezone === 'Z') {\n      return new Date(Date.UTC(y, m - 1, d));\n    }\n\n    return new Date(`${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`);\n  }\n\n  parseDateTime(timezone) {\n    const str = this.readLengthCodedString('binary');\n\n    if (str === null) {\n      return null;\n    }\n\n    if (!timezone || timezone === 'local') {\n      return new Date(str);\n    }\n\n    return new Date(`${str}${timezone}`);\n  }\n\n  parseFloat(len) {\n    if (len === null) {\n      return null;\n    }\n\n    let result = 0;\n    const end = this.offset + len;\n    let factor = 1;\n    let pastDot = false;\n    let charCode = 0;\n\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      factor = -1;\n    }\n\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n\n    while (this.offset < end) {\n      charCode = this.buffer[this.offset];\n\n      if (charCode === dot) {\n        pastDot = true;\n        this.offset++;\n      } else if (charCode === exponent || charCode === exponentCapital) {\n        this.offset++;\n        const exponentValue = this.parseInt(end - this.offset);\n        return result / factor * Math.pow(10, exponentValue);\n      } else {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n\n        if (pastDot) {\n          factor = factor * 10;\n        }\n      }\n    }\n\n    return result / factor;\n  }\n\n  parseLengthCodedIntNoBigCheck() {\n    return this.parseIntNoBigCheck(this.readLengthCodedNumber());\n  }\n\n  parseLengthCodedInt(supportBigNumbers) {\n    return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);\n  }\n\n  parseLengthCodedIntString() {\n    return this.readLengthCodedString('binary');\n  }\n\n  parseLengthCodedFloat() {\n    return this.parseFloat(this.readLengthCodedNumber());\n  }\n\n  peekByte() {\n    return this.buffer[this.offset];\n  } // OxFE is often used as \"Alt\" flag - not ok, not error.\n  // For example, it's first byte of AuthSwitchRequest\n\n\n  isAlt() {\n    return this.peekByte() === 0xfe;\n  }\n\n  isError() {\n    return this.peekByte() === 0xff;\n  }\n\n  asError(encoding) {\n    this.reset();\n    this.readInt8(); // fieldCount\n\n    const errorCode = this.readInt16();\n    let sqlState = '';\n\n    if (this.buffer[this.offset] === 0x23) {\n      this.skip(1);\n      sqlState = this.readBuffer(5).toString();\n    }\n\n    const message = this.readString(undefined, encoding);\n    const err = new Error(message);\n    err.code = ErrorCodeToName[errorCode];\n    err.errno = errorCode;\n    err.sqlState = sqlState;\n    err.sqlMessage = message;\n    return err;\n  }\n\n  writeInt32(n) {\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n  }\n\n  writeInt24(n) {\n    this.writeInt8(n & 0xff);\n    this.writeInt16(n >> 8);\n  }\n\n  writeInt16(n) {\n    this.buffer.writeUInt16LE(n, this.offset);\n    this.offset += 2;\n  }\n\n  writeInt8(n) {\n    this.buffer.writeUInt8(n, this.offset);\n    this.offset++;\n  }\n\n  writeDouble(n) {\n    this.buffer.writeDoubleLE(n, this.offset);\n    this.offset += 8;\n  }\n\n  writeBuffer(b) {\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeNull() {\n    this.buffer[this.offset] = 0xfb;\n    this.offset++;\n  } // TODO: refactor following three?\n\n\n  writeNullTerminatedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n    this.writeInt8(0);\n  }\n\n  writeString(s, encoding) {\n    if (s === null) {\n      this.writeInt8(0xfb);\n      return;\n    }\n\n    if (s.length === 0) {\n      return;\n    } // const bytes = Buffer.byteLength(s, 'utf8');\n    // this.buffer.write(s, this.offset, bytes, 'utf8');\n    // this.offset += bytes;\n\n\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.writeLengthCodedNumber(buf.length);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedBuffer(b) {\n    this.writeLengthCodedNumber(b.length);\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeLengthCodedNumber(n) {\n    if (n < 0xfb) {\n      return this.writeInt8(n);\n    }\n\n    if (n < 0xffff) {\n      this.writeInt8(0xfc);\n      return this.writeInt16(n);\n    }\n\n    if (n < 0xffffff) {\n      this.writeInt8(0xfd);\n      return this.writeInt24(n);\n    }\n\n    if (n === null) {\n      return this.writeInt8(0xfb);\n    } // TODO: check that n is out of int precision\n\n\n    this.writeInt8(0xfe);\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n    this.buffer.writeUInt32LE(n >> 32, this.offset);\n    this.offset += 4;\n    return this.offset;\n  }\n\n  writeDate(d, timezone) {\n    this.buffer.writeUInt8(11, this.offset);\n\n    if (!timezone || timezone === 'local') {\n      this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);\n    } else {\n      if (timezone !== 'Z') {\n        const offset = (timezone[0] === '-' ? -1 : 1) * (parseInt(timezone.substring(1, 3), 10) * 60 + parseInt(timezone.substring(4), 10));\n\n        if (offset !== 0) {\n          d = new Date(d.getTime() + 60000 * offset);\n        }\n      }\n\n      this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);\n    }\n\n    this.offset += 12;\n  }\n\n  writeHeader(sequenceId) {\n    const offset = this.offset;\n    this.offset = 0;\n    this.writeInt24(this.buffer.length - 4);\n    this.writeInt8(sequenceId);\n    this.offset = offset;\n  }\n\n  clone() {\n    return new Packet(this.sequenceId, this.buffer, this.start, this.end);\n  }\n\n  type() {\n    if (this.isEOF()) {\n      return 'EOF';\n    }\n\n    if (this.isError()) {\n      return 'Error';\n    }\n\n    if (this.buffer[this.offset] === 0) {\n      return 'maybeOK'; // could be other packet types as well\n    }\n\n    return '';\n  }\n\n  static lengthCodedNumberLength(n) {\n    if (n < 0xfb) {\n      return 1;\n    }\n\n    if (n < 0xffff) {\n      return 3;\n    }\n\n    if (n < 0xffffff) {\n      return 5;\n    }\n\n    return 9;\n  }\n\n  static lengthCodedStringLength(str, encoding) {\n    const buf = StringParser.encode(str, encoding);\n    const slen = buf.length;\n    return Packet.lengthCodedNumberLength(slen) + slen;\n  }\n\n  static MockBuffer() {\n    const noop = function () {};\n\n    const res = Buffer.alloc(0);\n\n    for (const op in NativeBuffer.prototype) {\n      if (typeof res[op] === 'function') {\n        res[op] = noop;\n      }\n    }\n\n    return res;\n  }\n\n}\n\nmodule.exports = Packet;","map":{"version":3,"names":["ErrorCodeToName","require","NativeBuffer","Buffer","Long","StringParser","INVALID_DATE","Date","NaN","pad","leftPad","num","value","s","toString","length","slice","minus","charCodeAt","plus","dot","exponent","exponentCapital","Packet","constructor","id","buffer","start","end","sequenceId","numPackets","offset","reset","dump","console","log","asciiSlice","haveMoreData","skip","readInt8","readInt16","readUInt16LE","readInt24","readInt32","readUInt32LE","readSInt8","readSInt16","readInt16LE","readSInt32","readInt32LE","readInt64JSNumber","word0","word1","l","toNumber","readSInt64JSNumber","readInt64String","res","readSInt64String","readInt64","resNumber","resString","readSInt64","isEOF","eofStatusFlags","eofWarningCount","readLengthCodedNumber","bigNumberStrings","signed","byte1","readLengthCodedNumberExt","readLengthCodedNumberSigned","tag","trace","Error","readFloat","readFloatLE","readDouble","readDoubleLE","readBuffer","len","readDateTime","timezone","y","m","d","H","M","S","ms","UTC","str","readDateTimeString","decimals","timeSep","join","substring","readTimeString","convertTtoMs","sign","replace","readLengthCodedString","encoding","decode","readLengthCodedBuffer","readNullTerminatedString","readString","undefined","parseInt","supportBigNumbers","Number","result","numDigits","parseIntNoBigCheck","parseGeometryValue","parseGeometry","x","i","j","numPoints","line","byteOrder","readUInt8","wkbType","readUInt32BE","readDoubleBE","push","numRings","parseDate","strLen","parseDateTime","parseFloat","factor","pastDot","charCode","exponentValue","Math","pow","parseLengthCodedIntNoBigCheck","parseLengthCodedInt","parseLengthCodedIntString","parseLengthCodedFloat","peekByte","isAlt","isError","asError","errorCode","sqlState","message","err","code","errno","sqlMessage","writeInt32","n","writeUInt32LE","writeInt24","writeInt8","writeInt16","writeUInt16LE","writeUInt8","writeDouble","writeDoubleLE","writeBuffer","b","copy","writeNull","writeNullTerminatedString","buf","encode","writeString","writeLengthCodedString","writeLengthCodedNumber","writeLengthCodedBuffer","writeDate","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","writeHeader","clone","type","lengthCodedNumberLength","lengthCodedStringLength","slen","MockBuffer","noop","alloc","op","prototype","module","exports"],"sources":["/home/emilio/Área de Trabalho/OneBitCode-aulas/REACT/site-react-login-live/react-controlledForms/node_modules/mysql2/lib/packets/packet.js"],"sourcesContent":["// This file was modified by Oracle on June 1, 2021.\n// A comment describing some changes in the strict default SQL mode regarding\n// non-standard dates was introduced.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n\n'use strict';\n\nconst ErrorCodeToName = require('../constants/errors.js');\nconst NativeBuffer = require('buffer').Buffer;\nconst Long = require('long');\nconst StringParser = require('../parsers/string.js');\n\nconst INVALID_DATE = new Date(NaN);\n\n// this is nearly duplicate of previous function so generated code is not slower\n// due to \"if (dateStrings)\" branching\nconst pad = '000000000000';\nfunction leftPad(num, value) {\n  const s = value.toString();\n  // if we don't need to pad\n  if (s.length >= num) {\n    return s;\n  }\n  return (pad + s).slice(-num);\n}\n\n// The whole reason parse* function below exist\n// is because String creation is relatively expensive (at least with V8), and if we have\n// a buffer with \"12345\" content ideally we would like to bypass intermediate\n// \"12345\" string creation and directly build 12345 number out of\n// <Buffer 31 32 33 34 35> data.\n// In my benchmarks the difference is ~25M 8-digit numbers per second vs\n// 4.5 M using Number(packet.readLengthCodedString())\n// not used when size is close to max precision as series of *10 accumulate error\n// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))\n// In the futire node version if speed difference is smaller parse* functions might be removed\n// don't consider them as Packet public API\n\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0);\n\n// TODO: handle E notation\nconst dot = '.'.charCodeAt(0);\nconst exponent = 'e'.charCodeAt(0);\nconst exponentCapital = 'E'.charCodeAt(0);\n\nclass Packet {\n  constructor(id, buffer, start, end) {\n    // hot path, enable checks when testing only\n    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')\n    //  throw new Error('invalid packet');\n    this.sequenceId = id;\n    this.numPackets = 1;\n    this.buffer = buffer;\n    this.start = start;\n    this.offset = start + 4;\n    this.end = end;\n  }\n\n  // ==============================\n  // readers\n  // ==============================\n  reset() {\n    this.offset = this.start + 4;\n  }\n\n  length() {\n    return this.end - this.start;\n  }\n\n  slice() {\n    return this.buffer.slice(this.start, this.end);\n  }\n\n  dump() {\n    // eslint-disable-next-line no-console\n    console.log(\n      [this.buffer.asciiSlice(this.start, this.end)],\n      this.buffer.slice(this.start, this.end),\n      this.length(),\n      this.sequenceId\n    );\n  }\n\n  haveMoreData() {\n    return this.end > this.offset;\n  }\n\n  skip(num) {\n    this.offset += num;\n  }\n\n  readInt8() {\n    return this.buffer[this.offset++];\n  }\n\n  readInt16() {\n    this.offset += 2;\n    return this.buffer.readUInt16LE(this.offset - 2);\n  }\n\n  readInt24() {\n    return this.readInt16() + (this.readInt8() << 16);\n  }\n\n  readInt32() {\n    this.offset += 4;\n    return this.buffer.readUInt32LE(this.offset - 4);\n  }\n\n  readSInt8() {\n    return this.buffer.readInt8(this.offset++);\n  }\n\n  readSInt16() {\n    this.offset += 2;\n    return this.buffer.readInt16LE(this.offset - 2);\n  }\n\n  readSInt32() {\n    this.offset += 4;\n    return this.buffer.readInt32LE(this.offset - 4);\n  }\n\n  readInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const l = new Long(word0, word1, true);\n    return l.toNumber();\n  }\n\n  readSInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    if (!(word1 & 0x80000000)) {\n      return word0 + 0x100000000 * word1;\n    }\n    const l = new Long(word0, word1, false);\n    return l.toNumber();\n  }\n\n  readInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, true);\n    return res.toString();\n  }\n\n  readSInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, false);\n    return res.toString();\n  }\n\n  readInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, true);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  readSInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, false);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  isEOF() {\n    return this.buffer[this.offset] === 0xfe && this.length() < 13;\n  }\n\n  eofStatusFlags() {\n    return this.buffer.readInt16LE(this.offset + 3);\n  }\n\n  eofWarningCount() {\n    return this.buffer.readInt16LE(this.offset + 1);\n  }\n\n  readLengthCodedNumber(bigNumberStrings, signed) {\n    const byte1 = this.buffer[this.offset++];\n    if (byte1 < 251) {\n      return byte1;\n    }\n    return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);\n  }\n\n  readLengthCodedNumberSigned(bigNumberStrings) {\n    return this.readLengthCodedNumber(bigNumberStrings, true);\n  }\n\n  readLengthCodedNumberExt(tag, bigNumberStrings, signed) {\n    let word0, word1;\n    let res;\n    if (tag === 0xfb) {\n      return null;\n    }\n    if (tag === 0xfc) {\n      return this.readInt8() + (this.readInt8() << 8);\n    }\n    if (tag === 0xfd) {\n      return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);\n    }\n    if (tag === 0xfe) {\n      // TODO: check version\n      // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.\n      word0 = this.readInt32();\n      word1 = this.readInt32();\n      if (word1 === 0) {\n        return word0; // don't convert to float if possible\n      }\n      if (word1 < 2097152) {\n        // max exact float point int, 2^52 / 2^32\n        return word1 * 0x100000000 + word0;\n      }\n      res = new Long(word0, word1, !signed); // Long need unsigned\n      const resNumber = res.toNumber();\n      const resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return bigNumberStrings ? resString : res;\n    }\n    // eslint-disable-next-line no-console\n    console.trace();\n    throw new Error(`Should not reach here: ${tag}`);\n  }\n\n  readFloat() {\n    const res = this.buffer.readFloatLE(this.offset);\n    this.offset += 4;\n    return res;\n  }\n\n  readDouble() {\n    const res = this.buffer.readDoubleLE(this.offset);\n    this.offset += 8;\n    return res;\n  }\n\n  readBuffer(len) {\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return this.buffer.slice(this.offset - len, this.offset);\n  }\n\n  // DATE, DATETIME and TIMESTAMP\n  readDateTime(timezone) {\n    if (!timezone || timezone === 'Z' || timezone === 'local') {\n      const length = this.readInt8();\n      if (length === 0xfb) {\n        return null;\n      }\n      let y = 0;\n      let m = 0;\n      let d = 0;\n      let H = 0;\n      let M = 0;\n      let S = 0;\n      let ms = 0;\n      if (length > 3) {\n        y = this.readInt16();\n        m = this.readInt8();\n        d = this.readInt8();\n      }\n      if (length > 6) {\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n      }\n      if (length > 10) {\n        ms = this.readInt32() / 1000;\n      }\n      // NO_ZERO_DATE mode and NO_ZERO_IN_DATE mode are part of the strict\n      // default SQL mode used by MySQL 8.0. This means that non-standard\n      // dates like '0000-00-00' become NULL. For older versions and other\n      // possible MySQL flavours we still need to account for the\n      // non-standard behaviour.\n      if (y + m + d + H + M + S + ms === 0) {\n        return INVALID_DATE;\n      }\n      if (timezone === 'Z') {\n        return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));\n      }\n      return new Date(y, m - 1, d, H, M, S, ms);\n    }\n    let str = this.readDateTimeString(6, 'T');\n    if (str.length === 10) {\n      str += 'T00:00:00';\n    }\n    return new Date(str + timezone);\n  }\n\n  readDateTimeString(decimals, timeSep) {\n    const length = this.readInt8();\n    let y = 0;\n    let m = 0;\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    let str;\n    if (length > 3) {\n      y = this.readInt16();\n      m = this.readInt8();\n      d = this.readInt8();\n      str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');\n    }\n    if (length > 6) {\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n      str += `${timeSep || ' '}${[\n        leftPad(2, H),\n        leftPad(2, M),\n        leftPad(2, S)\n      ].join(':')}`;\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n      str += '.';\n      if (decimals) {\n        ms = leftPad(6, ms);\n        if (ms.length > decimals) {\n          ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here\n        }\n      }\n      str += ms;\n    }\n    return str;\n  }\n\n  // TIME - value as a string, Can be negative\n  readTimeString(convertTtoMs) {\n    const length = this.readInt8();\n    if (length === 0) {\n      return '00:00:00';\n    }\n    const sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    if (length > 6) {\n      d = this.readInt32();\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n    }\n    if (convertTtoMs) {\n      H += d * 24;\n      M += H * 60;\n      S += M * 60;\n      ms += S * 1000;\n      ms *= sign;\n      return ms;\n    }\n    // Format follows mySQL TIME format ([-][h]hh:mm:ss[.u[u[u[u[u[u]]]]]])\n    // For positive times below 24 hours, this makes it equal to ISO 8601 times\n    return (\n      (sign === -1 ? '-' : '') +\n      [leftPad(2, d * 24 + H), leftPad(2, M), leftPad(2, S)].join(':') +\n      (ms ? `.${ms}`.replace(/0+$/, '') : '')\n    );\n  }\n\n  readLengthCodedString(encoding) {\n    const len = this.readLengthCodedNumber();\n    // TODO: check manually first byte here to avoid polymorphic return type?\n    if (len === null) {\n      return null;\n    }\n    this.offset += len;\n    // TODO: Use characterSetCode to get proper encoding\n    // https://github.com/sidorares/node-mysql2/pull/374\n    return StringParser.decode(\n      this.buffer,\n      encoding,\n      this.offset - len,\n      this.offset\n    );\n  }\n\n  readLengthCodedBuffer() {\n    const len = this.readLengthCodedNumber();\n    if (len === null) {\n      return null;\n    }\n    return this.readBuffer(len);\n  }\n\n  readNullTerminatedString(encoding) {\n    const start = this.offset;\n    let end = this.offset;\n    while (this.buffer[end]) {\n      end = end + 1; // TODO: handle OOB check\n    }\n    this.offset = end + 1;\n    return StringParser.decode(this.buffer, encoding, start, end);\n  }\n\n  // TODO reuse?\n  readString(len, encoding) {\n    if (typeof len === 'string' && typeof encoding === 'undefined') {\n      encoding = len;\n      len = undefined;\n    }\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return StringParser.decode(\n      this.buffer,\n      encoding,\n      this.offset - len, \n      this.offset\n    );\n  }\n\n  parseInt(len, supportBigNumbers) {\n    if (len === null) {\n      return null;\n    }\n    if (len >= 14 && !supportBigNumbers) {\n      const s = this.buffer.toString('ascii', this.offset, this.offset + len);\n      this.offset += len;\n      return Number(s);\n    }\n    let result = 0;\n    const start = this.offset;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    // max precise int is 9007199254740992\n    let str;\n    const numDigits = end - this.offset;\n    if (supportBigNumbers) {\n      if (numDigits >= 15) {\n        str = this.readString(end - this.offset, 'binary');\n        result = parseInt(str, 10);\n        if (result.toString() === str) {\n          return sign * result;\n        }\n        return sign === -1 ? `-${str}` : str;\n      }\n      if (numDigits > 16) {\n        str = this.readString(end - this.offset);\n        return sign === -1 ? `-${str}` : str;\n      }\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    const num = result * sign;\n    if (!supportBigNumbers) {\n      return num;\n    }\n    str = this.buffer.toString('ascii', start, end);\n    if (num.toString() === str) {\n      return num;\n    }\n    return str;\n  }\n\n  // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER\n  // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be\n  // different from what you would get from Number(inputNumberAsString)\n  // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString\n  parseIntNoBigCheck(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    return result * sign;\n  }\n\n  // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js\n  parseGeometryValue() {\n    const buffer = this.readLengthCodedBuffer();\n    let offset = 4;\n    if (buffer === null || !buffer.length) {\n      return null;\n    }\n    function parseGeometry() {\n      let x, y, i, j, numPoints, line;\n      let result = null;\n      const byteOrder = buffer.readUInt8(offset);\n      offset += 1;\n      const wkbType = byteOrder\n        ? buffer.readUInt32LE(offset)\n        : buffer.readUInt32BE(offset);\n      offset += 4;\n      switch (wkbType) {\n        case 1: // WKBPoint\n          x = byteOrder\n            ? buffer.readDoubleLE(offset)\n            : buffer.readDoubleBE(offset);\n          offset += 8;\n          y = byteOrder\n            ? buffer.readDoubleLE(offset)\n            : buffer.readDoubleBE(offset);\n          offset += 8;\n          result = { x: x, y: y };\n          break;\n        case 2: // WKBLineString\n          numPoints = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numPoints; i > 0; i--) {\n            x = byteOrder\n              ? buffer.readDoubleLE(offset)\n              : buffer.readDoubleBE(offset);\n            offset += 8;\n            y = byteOrder\n              ? buffer.readDoubleLE(offset)\n              : buffer.readDoubleBE(offset);\n            offset += 8;\n            result.push({ x: x, y: y });\n          }\n          break;\n        case 3: // WKBPolygon\n          // eslint-disable-next-line no-case-declarations\n          const numRings = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numRings; i > 0; i--) {\n            numPoints = byteOrder\n              ? buffer.readUInt32LE(offset)\n              : buffer.readUInt32BE(offset);\n            offset += 4;\n            line = [];\n            for (j = numPoints; j > 0; j--) {\n              x = byteOrder\n                ? buffer.readDoubleLE(offset)\n                : buffer.readDoubleBE(offset);\n              offset += 8;\n              y = byteOrder\n                ? buffer.readDoubleLE(offset)\n                : buffer.readDoubleBE(offset);\n              offset += 8;\n              line.push({ x: x, y: y });\n            }\n            result.push(line);\n          }\n          break;\n        case 4: // WKBMultiPoint\n        case 5: // WKBMultiLineString\n        case 6: // WKBMultiPolygon\n        case 7: // WKBGeometryCollection\n          // eslint-disable-next-line no-case-declarations\n          const num = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = num; i > 0; i--) {\n            result.push(parseGeometry());\n          }\n          break;\n      }\n      return result;\n    }\n    return parseGeometry();\n  }\n\n  parseDate(timezone) {\n    const strLen = this.readLengthCodedNumber();\n    if (strLen === null) {\n      return null;\n    }\n    if (strLen !== 10) {\n      // we expect only YYYY-MM-DD here.\n      // if for some reason it's not the case return invalid date\n      return new Date(NaN);\n    }\n    const y = this.parseInt(4);\n    this.offset++; // -\n    const m = this.parseInt(2);\n    this.offset++; // -\n    const d = this.parseInt(2);\n    if (!timezone || timezone === 'local') {\n      return new Date(y, m - 1, d);\n    }\n    if (timezone === 'Z') {\n      return new Date(Date.UTC(y, m - 1, d));\n    }\n    return new Date(\n      `${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`\n    );\n  }\n\n  parseDateTime(timezone) {\n    const str = this.readLengthCodedString('binary');\n    if (str === null) {\n      return null;\n    }\n    if (!timezone || timezone === 'local') {\n      return new Date(str);\n    }\n    return new Date(`${str}${timezone}`);\n  }\n\n  parseFloat(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let factor = 1;\n    let pastDot = false;\n    let charCode = 0;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      factor = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      charCode = this.buffer[this.offset];\n      if (charCode === dot) {\n        pastDot = true;\n        this.offset++;\n      } else if (charCode === exponent || charCode === exponentCapital) {\n        this.offset++;\n        const exponentValue = this.parseInt(end - this.offset);\n        return (result / factor) * Math.pow(10, exponentValue);\n      } else {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n        if (pastDot) {\n          factor = factor * 10;\n        }\n      }\n    }\n    return result / factor;\n  }\n\n  parseLengthCodedIntNoBigCheck() {\n    return this.parseIntNoBigCheck(this.readLengthCodedNumber());\n  }\n\n  parseLengthCodedInt(supportBigNumbers) {\n    return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);\n  }\n\n  parseLengthCodedIntString() {\n    return this.readLengthCodedString('binary');\n  }\n\n  parseLengthCodedFloat() {\n    return this.parseFloat(this.readLengthCodedNumber());\n  }\n\n  peekByte() {\n    return this.buffer[this.offset];\n  }\n\n  // OxFE is often used as \"Alt\" flag - not ok, not error.\n  // For example, it's first byte of AuthSwitchRequest\n  isAlt() {\n    return this.peekByte() === 0xfe;\n  }\n\n  isError() {\n    return this.peekByte() === 0xff;\n  }\n\n  asError(encoding) {\n    this.reset();\n    this.readInt8(); // fieldCount\n    const errorCode = this.readInt16();\n    let sqlState = '';\n    if (this.buffer[this.offset] === 0x23) {\n      this.skip(1);\n      sqlState = this.readBuffer(5).toString();\n    }\n    const message = this.readString(undefined, encoding);\n    const err = new Error(message);\n    err.code = ErrorCodeToName[errorCode];\n    err.errno = errorCode;\n    err.sqlState = sqlState;\n    err.sqlMessage = message;\n    return err;\n  }\n\n  writeInt32(n) {\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n  }\n\n  writeInt24(n) {\n    this.writeInt8(n & 0xff);\n    this.writeInt16(n >> 8);\n  }\n\n  writeInt16(n) {\n    this.buffer.writeUInt16LE(n, this.offset);\n    this.offset += 2;\n  }\n\n  writeInt8(n) {\n    this.buffer.writeUInt8(n, this.offset);\n    this.offset++;\n  }\n\n  writeDouble(n) {\n    this.buffer.writeDoubleLE(n, this.offset);\n    this.offset += 8;\n  }\n\n  writeBuffer(b) {\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeNull() {\n    this.buffer[this.offset] = 0xfb;\n    this.offset++;\n  }\n\n  // TODO: refactor following three?\n  writeNullTerminatedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n    this.writeInt8(0);\n  }\n\n  writeString(s, encoding) {\n    if (s === null) {\n      this.writeInt8(0xfb);\n      return;\n    }\n    if (s.length === 0) {\n      return;\n    }\n    // const bytes = Buffer.byteLength(s, 'utf8');\n    // this.buffer.write(s, this.offset, bytes, 'utf8');\n    // this.offset += bytes;\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.writeLengthCodedNumber(buf.length);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedBuffer(b) {\n    this.writeLengthCodedNumber(b.length);\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeLengthCodedNumber(n) {\n    if (n < 0xfb) {\n      return this.writeInt8(n);\n    }\n    if (n < 0xffff) {\n      this.writeInt8(0xfc);\n      return this.writeInt16(n);\n    }\n    if (n < 0xffffff) {\n      this.writeInt8(0xfd);\n      return this.writeInt24(n);\n    }\n    if (n === null) {\n      return this.writeInt8(0xfb);\n    }\n    // TODO: check that n is out of int precision\n    this.writeInt8(0xfe);\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n    this.buffer.writeUInt32LE(n >> 32, this.offset);\n    this.offset += 4;\n    return this.offset;\n  }\n\n  writeDate(d, timezone) {\n    this.buffer.writeUInt8(11, this.offset);\n    if (!timezone || timezone === 'local') {\n      this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);\n    } else {\n      if (timezone !== 'Z') {\n        const offset =\n          (timezone[0] === '-' ? -1 : 1) *\n          (parseInt(timezone.substring(1, 3), 10) * 60 +\n            parseInt(timezone.substring(4), 10));\n        if (offset !== 0) {\n          d = new Date(d.getTime() + 60000 * offset);\n        }\n      }\n      this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);\n    }\n    this.offset += 12;\n  }\n\n  writeHeader(sequenceId) {\n    const offset = this.offset;\n    this.offset = 0;\n    this.writeInt24(this.buffer.length - 4);\n    this.writeInt8(sequenceId);\n    this.offset = offset;\n  }\n\n  clone() {\n    return new Packet(this.sequenceId, this.buffer, this.start, this.end);\n  }\n\n  type() {\n    if (this.isEOF()) {\n      return 'EOF';\n    }\n    if (this.isError()) {\n      return 'Error';\n    }\n    if (this.buffer[this.offset] === 0) {\n      return 'maybeOK'; // could be other packet types as well\n    }\n    return '';\n  }\n\n  static lengthCodedNumberLength(n) {\n    if (n < 0xfb) {\n      return 1;\n    }\n    if (n < 0xffff) {\n      return 3;\n    }\n    if (n < 0xffffff) {\n      return 5;\n    }\n    return 9;\n  }\n\n  static lengthCodedStringLength(str, encoding) {\n    const buf = StringParser.encode(str, encoding);\n    const slen = buf.length;\n    return Packet.lengthCodedNumberLength(slen) + slen;\n  }\n\n  static MockBuffer() {\n    const noop = function () {};\n    const res = Buffer.alloc(0);\n    for (const op in NativeBuffer.prototype) {\n      if (typeof res[op] === 'function') {\n        res[op] = noop;\n      }\n    }\n    return res;\n  }\n}\n\nmodule.exports = Packet;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}